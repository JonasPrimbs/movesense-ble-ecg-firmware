#pragma once
/***********************************************************************
* THIS FILE HAS BEEN GENERATED BY WBRES TOOL. DO NOT TRY TO CHANGE IT. *
***********************************************************************/
// Copyright (c) Suunto Oy 2014 - 2017. All rights reserved.

#include "whiteboard/Identifiers.h"
#include "whiteboard/ParameterList.h"
#include "whiteboard/Result.h"
#include "whiteboard/ResourceClient.h"

#include "whiteboard/builtinTypes/Array.h"
#include "whiteboard/builtinTypes/ByteStream.h"
#include "whiteboard/builtinTypes/Date.h"
#include "whiteboard/builtinTypes/DateTime.h"
#include "whiteboard/builtinTypes/Optional.h"
#include "whiteboard/builtinTypes/Structures.h"
#include "whiteboard/builtinTypes/Time.h"
#include "whiteboard/builtinTypes/Timestamp.h"
#include "whiteboard/builtinTypes/TypedEnum.h"
#include "whiteboard/builtinTypes/Vector2D.h"
#include "whiteboard/builtinTypes/Vector3D.h"
#include "whiteboard/builtinTypes/WrapperFor32BitPointer.h"

#define WB_RESOURCE_VALUE(whiteboardId, localResourceId, executionContextId) \
    static_cast<whiteboard::ResourceId::Value>( \
        (static_cast<uint32>(localResourceId) << 16) | \
        (static_cast<uint32>(whiteboardId) << 8) | \
        (static_cast<uint32>(executionContextId) << 4) | \
        (static_cast<uint32>(whiteboard::ID_INVALID_RESOURCE_INSTANCE)))


#include "../wb-resources/resources.h"
#include "../movesense_types/resources.h"

#define WB_EXEC_CTX_APPLICATION                  static_cast<whiteboard::ExecutionContextId>(0)
#define WB_EXEC_CTX_MEAS                         static_cast<whiteboard::ExecutionContextId>(1)

namespace WB_RES {

struct PeerStateValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14087;

	enum Type
	{
		DISCONNECTED = 0U,
		CONNECTED = 1U
	};
};
typedef whiteboard::TypedEnum<PeerStateValues, PeerStateValues::Type, uint8> PeerState;

struct BondingPolicyValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14093;

	enum Type
	{
		BONDINGENABLED = 0U,
		BONDINGDISABLED = 1U,
		BONDINGONCE = 2U,
		BONDINGSAMEMAC = 3U
	};
};
typedef whiteboard::TypedEnum<BondingPolicyValues, BondingPolicyValues::Type, uint8> BondingPolicy;

struct WB_ALIGN(4) BleConfig;
struct WB_ALIGN(4) AdvParams;
struct WB_ALIGN(4) AdvState;
struct WB_ALIGN(1) AdvProps;
struct WB_ALIGN(4) AdvSettings;
struct WB_ALIGN(4) PeerEntry;
struct WB_ALIGN(4) PeerList;
struct WB_ALIGN(4) PeerChange;
struct WB_ALIGN(2) ScanParams;
struct WB_ALIGN(4) ScanResult;
struct WB_ALIGN(4) BondEntry;
struct WB_ALIGN(4) BondList;
struct WB_ALIGN(2) BondingSettings;

struct WB_ALIGN(4) BleConfig
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14080;

	WB_ALIGN(4) whiteboard::Optional< whiteboard::WrapperFor32BitPointer< const char > > deviceName;
};

struct WB_ALIGN(4) AdvParams
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14081;

	WB_ALIGN(4) whiteboard::Optional< whiteboard::WrapperFor32BitPointer< whiteboard::RemovePointer<MacAddress48>::type > > peerAddr;
};

struct WB_ALIGN(4) AdvState
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14082;

	WB_ALIGN(1) bool isAdvertising;
	WB_ALIGN(4) whiteboard::Optional< whiteboard::WrapperFor32BitPointer< whiteboard::RemovePointer<MacAddress48>::type > > peerAddr;
};

struct WB_ALIGN(1) AdvProps
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14083;

	WB_ALIGN(1) bool connectable;
	WB_ALIGN(1) bool scannable;
	WB_ALIGN(1) bool anonymous;
};

struct WB_ALIGN(4) AdvSettings
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14084;

	WB_ALIGN(4) whiteboard::Optional< whiteboard::Array< uint8 > > advPacket;
	WB_ALIGN(4) whiteboard::Optional< whiteboard::Array< uint8 > > scanRespPacket;
	WB_ALIGN(2) uint16 interval;
	WB_ALIGN(2) uint16 timeout;
	WB_ALIGN(1) whiteboard::Optional< AdvProps > properties;
};

struct WB_ALIGN(4) PeerEntry
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14085;

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer< whiteboard::RemovePointer<MacAddress48>::type > address;
	WB_ALIGN(4) whiteboard::Optional< whiteboard::WrapperFor32BitPointer< const char > > name;
	WB_ALIGN(4) whiteboard::Optional< uint32 > handle;
};

struct WB_ALIGN(4) PeerList
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14086;

	WB_ALIGN(4) whiteboard::Array< PeerEntry > connectedPeers;
};

struct WB_ALIGN(4) PeerChange
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14088;

	WB_ALIGN(4) PeerEntry peer;
	WB_ALIGN(1) PeerState state;
};

struct WB_ALIGN(2) ScanParams
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14089;

	WB_ALIGN(1) bool active;
	WB_ALIGN(2) uint16 timeout;
	WB_ALIGN(2) uint16 window;
	WB_ALIGN(2) uint16 interval;
};

struct WB_ALIGN(4) ScanResult
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14090;

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer< whiteboard::RemovePointer<MacAddress48>::type > address;
	WB_ALIGN(1) bool isScanResponse;
	WB_ALIGN(1) int8 rssi;
	WB_ALIGN(4) whiteboard::Array< uint8 > dataPacket;
	WB_ALIGN(4) whiteboard::Optional< whiteboard::WrapperFor32BitPointer< const char > > name;
};

struct WB_ALIGN(4) BondEntry
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14091;

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer< whiteboard::RemovePointer<MacAddress48>::type > address;
};

struct WB_ALIGN(4) BondList
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14092;

	WB_ALIGN(4) whiteboard::Array< BondEntry > bondedDevices;
};

struct WB_ALIGN(2) BondingSettings
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 14094;

	WB_ALIGN(1) BondingPolicy policy;
	WB_ALIGN(2) uint16 recoveryTime;
};

namespace LOCAL 
{

struct ROOT;

struct COMM;

struct COMM_BLE;

struct COMM_BLE_ADDR
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 14080, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 14080;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<MacAddress48, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct COMM_BLE_ADV
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 14081, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 14081;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const AdvState&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};

	struct POST
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_CREATED> HTTP_CODE_CREATED;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_CONFLICT> HTTP_CODE_CONFLICT;

		struct Parameters
		{
			struct DATA
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef AdvParams Type;
				typedef const Type& ConstReferenceType;
			};

			typedef DATA Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Comm/Ble/Adv */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Checks whether optional parameter DATA has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasData() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::DATA::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::DATA::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets DATA parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::DATA::ConstReferenceType getData() const
			{
				return mrParameterList[Parameters::DATA::Index].convertTo<Parameters::DATA::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<Parameters::DATA::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};

	struct DELETE
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct COMM_BLE_ADV_SETTINGS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 14082, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 14082;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const AdvSettings&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};

	struct PUT
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_BAD_REQUEST> HTTP_CODE_BAD_REQUEST;

		struct Parameters
		{
			struct NEWSETTINGS
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef AdvSettings Type;
				typedef const Type& ConstReferenceType;
			};

			typedef NEWSETTINGS Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Comm/Ble/Adv/Settings */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets NEWSETTINGS parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::NEWSETTINGS::ConstReferenceType getNewSettings() const
			{
				return mrParameterList[Parameters::NEWSETTINGS::Index].convertTo<Parameters::NEWSETTINGS::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::NEWSETTINGS::ConstReferenceType)
		{
		}
	};
};

struct COMM_BLE_CONFIG
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 14083, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 14083;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const BleConfig&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};

	struct PUT
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_BAD_REQUEST> HTTP_CODE_BAD_REQUEST;

		struct Parameters
		{
			struct NEWCONFIG
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef BleConfig Type;
				typedef const Type& ConstReferenceType;
			};

			typedef NEWCONFIG Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Comm/Ble/Config */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets NEWCONFIG parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::NEWCONFIG::ConstReferenceType getNewConfig() const
			{
				return mrParameterList[Parameters::NEWCONFIG::Index].convertTo<Parameters::NEWCONFIG::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::NEWCONFIG::ConstReferenceType)
		{
		}
	};
};

struct COMM_BLE_PEERS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 14084, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 14084;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const PeerList&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};

	struct SUBSCRIBE
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};

	struct EVENT
	{
		typedef PeerChange NotificationType;
		typedef const NotificationType& ConstReferenceNotificationType;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<ConstReferenceNotificationType>&)
		{
		}
	};

	struct UNSUBSCRIBE
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct COMM_BLE_PEERS_CONNHANDLE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 14085, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 14085;

	struct DELETE
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			struct CONNHANDLE
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef int32 Type;
				typedef Type ConstReferenceType;
			};

			typedef CONNHANDLE Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Comm/Ble/Peers/{ConnHandle} */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets CONNHANDLE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::CONNHANDLE::ConstReferenceType getConnHandle() const
			{
				return mrParameterList[Parameters::CONNHANDLE::Index].convertTo<Parameters::CONNHANDLE::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::CONNHANDLE::ConstReferenceType)
		{
		}
	};
};

struct COMM_BLE_SCAN
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 14086, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 14086;

	struct SUBSCRIBE
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			struct PARAMS
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef ScanParams Type;
				typedef const Type& ConstReferenceType;
			};

			typedef PARAMS Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Comm/Ble/Scan */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Checks whether optional parameter PARAMS has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasParams() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::PARAMS::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::PARAMS::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets PARAMS parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::PARAMS::ConstReferenceType getParams() const
			{
				return mrParameterList[Parameters::PARAMS::Index].convertTo<Parameters::PARAMS::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<Parameters::PARAMS::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};

	struct EVENT
	{
		typedef ScanResult NotificationType;
		typedef const NotificationType& ConstReferenceNotificationType;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<ConstReferenceNotificationType>&)
		{
		}
	};

	struct UNSUBSCRIBE
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct COMM_BLE_SECURITY;

struct COMM_BLE_SECURITY_BONDS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 14087, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 14087;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const BondList&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};

	struct DELETE
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_BAD_REQUEST> HTTP_CODE_BAD_REQUEST;

		struct Parameters
		{
			struct MACADDR
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef MacAddress48 Type;
				typedef Type ConstReferenceType;
			};

			typedef MACADDR Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Comm/Ble/Security/Bonds */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Checks whether optional parameter MACADDR has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasMacAddr() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::MACADDR::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::MACADDR::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets MACADDR parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::MACADDR::ConstReferenceType getMacAddr() const
			{
				return mrParameterList[Parameters::MACADDR::Index].convertTo<Parameters::MACADDR::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<Parameters::MACADDR::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};
};

struct COMM_BLE_SECURITY_PIN
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 14088, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 14088;

	struct PUT
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			struct PINCODE
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef const char* Type;
				typedef Type ConstReferenceType;
			};

			typedef PINCODE Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Comm/Ble/Security/Pin */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets PINCODE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::PINCODE::ConstReferenceType getPincode() const
			{
				return mrParameterList[Parameters::PINCODE::Index].convertTo<Parameters::PINCODE::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::PINCODE::ConstReferenceType)
		{
		}
	};

	struct DELETE
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct COMM_BLE_SECURITY_SETTINGS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 14089, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 14089;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const BondingSettings&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};

	struct PUT
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_BAD_REQUEST> HTTP_CODE_BAD_REQUEST;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_IMPLEMENTED> HTTP_CODE_NOT_IMPLEMENTED;

		struct Parameters
		{
			struct NEWSETTINGS
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef BondingSettings Type;
				typedef const Type& ConstReferenceType;
			};

			typedef NEWSETTINGS Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Comm/Ble/Security/Settings */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets NEWSETTINGS parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::NEWSETTINGS::ConstReferenceType getNewSettings() const
			{
				return mrParameterList[Parameters::NEWSETTINGS::Index].convertTo<Parameters::NEWSETTINGS::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::NEWSETTINGS::ConstReferenceType)
		{
		}
	};
};



} // namespace LOCAL 

} // namespace WB_RES
