#pragma once
/***********************************************************************
* THIS FILE HAS BEEN GENERATED BY WBRES TOOL. DO NOT TRY TO CHANGE IT. *
***********************************************************************/
// Copyright (c) Suunto Oy 2014 - 2017. All rights reserved.

#include "whiteboard/Identifiers.h"
#include "whiteboard/ParameterList.h"
#include "whiteboard/Result.h"
#include "whiteboard/ResourceClient.h"

#include "whiteboard/builtinTypes/Array.h"
#include "whiteboard/builtinTypes/ByteStream.h"
#include "whiteboard/builtinTypes/Date.h"
#include "whiteboard/builtinTypes/DateTime.h"
#include "whiteboard/builtinTypes/Optional.h"
#include "whiteboard/builtinTypes/Structures.h"
#include "whiteboard/builtinTypes/Time.h"
#include "whiteboard/builtinTypes/Timestamp.h"
#include "whiteboard/builtinTypes/TypedEnum.h"
#include "whiteboard/builtinTypes/Vector2D.h"
#include "whiteboard/builtinTypes/Vector3D.h"
#include "whiteboard/builtinTypes/WrapperFor32BitPointer.h"

#define WB_RESOURCE_VALUE(whiteboardId, localResourceId, executionContextId) \
    static_cast<whiteboard::ResourceId::Value>( \
        (static_cast<uint32>(localResourceId) << 16) | \
        (static_cast<uint32>(whiteboardId) << 8) | \
        (static_cast<uint32>(executionContextId) << 4) | \
        (static_cast<uint32>(whiteboard::ID_INVALID_RESOURCE_INSTANCE)))


#define WB_EXEC_CTX_APPLICATION                  static_cast<whiteboard::ExecutionContextId>(0)

namespace WB_RES {

struct ThreadStateValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 258;

	enum Type
	{
		READY = 0U,
		RUNNING = 1U,
		BLOCKED = 2U,
		SUSPENDED = 3U,
		TERMINATED = 4U
	};
};
typedef whiteboard::TypedEnum<ThreadStateValues, ThreadStateValues::Type, uint8> ThreadState;

struct RouteStateValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 262;

	enum Type
	{
		ROUTE_STATE_NOT_USED = 0U,
		ROUTE_STATE_ADAPTER_DISABLED = 1U,
		ROUTE_STATE_NOT_CONNECTED = 2U,
		ROUTE_STATE_CONNECTING = 3U,
		ROUTE_STATE_HANDSHAKING = 4U,
		ROUTE_STATE_ESTABLISHED = 5U,
		ROUTE_STATE_DISCONNECTING = 6U,
		ROUTE_STATE_ERROR = 7U
	};
};
typedef whiteboard::TypedEnum<RouteStateValues, RouteStateValues::Type, uint8> RouteState;

struct RoutingTableNotificationTypeValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 263;

	enum Type
	{
		ROUTE_NOTIFICATION_NEW = 0U,
		ROUTE_NOTIFICATION_LOST = 1U,
		ROUTE_NOTIFICATION_ERROR = 2U
	};
};
typedef whiteboard::TypedEnum<RoutingTableNotificationTypeValues, RoutingTableNotificationTypeValues::Type, uint8> RoutingTableNotificationType;

struct ModuleCommandValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 265;

	enum Type
	{
		INITIALIZE = 0U,
		START = 1U,
		STOP = 2U,
		DEINITIALIZE = 3U
	};
};
typedef whiteboard::TypedEnum<ModuleCommandValues, ModuleCommandValues::Type, uint8> ModuleCommand;

struct ModuleStateValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 266;

	enum Type
	{
		UNINITIALIZED = 0U,
		INITIALIZED = 1U,
		STARTED = 2U,
		STOPPED = 3U,
		INITFAILED = 4U,
		FAILURE = 5U
	};
};
typedef whiteboard::TypedEnum<ModuleStateValues, ModuleStateValues::Type, uint8> ModuleState;

struct ThreadPriorityValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 270;

	enum Type
	{
		NOT_AVAILABLE = 0U,
		LOW = 1U,
		NORMAL = 2U,
		HIGH = 3U
	};
};
typedef whiteboard::TypedEnum<ThreadPriorityValues, ThreadPriorityValues::Type, uint8> ThreadPriority;

struct OperationTypeValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 36;

	enum Type
	{
		GET = 0U,
		PUT = 1U,
		POST = 2U,
		DELETE = 3U,
		SUBSCRIBE = 4U,
		UNSUBSCRIBE = 5U
	};
};
typedef whiteboard::TypedEnum<OperationTypeValues, OperationTypeValues::Type, uint8> OperationType;

struct DataTypeTypeValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 40;

	enum Type
	{
		SCALAR = 0U,
		NAMED = 1U,
		ARRAY = 2U,
		STRUCTURE = 3U,
		ENUMERATION = 4U
	};
};
typedef whiteboard::TypedEnum<DataTypeTypeValues, DataTypeTypeValues::Type, uint8> DataTypeType;

struct ScalarTypeValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 271;

	enum Type
	{
		NONE = 0U,
		BOOL = 1U,
		INT8 = 2U,
		UINT8 = 3U,
		INT16 = 4U,
		UINT16 = 5U,
		INT32 = 6U,
		UINT32 = 7U,
		INT64 = 8U,
		UINT64 = 9U,
		FLOAT = 10U,
		DOUBLE = 11U,
		STRING = 12U,
		LIST_OF_BYTES = 13U,
		BYTE_STREAM = 14U,
		HASH_STRING = 15U,
		STRUCTURE = 16U
	};
};
typedef whiteboard::TypedEnum<ScalarTypeValues, ScalarTypeValues::Type, uint8> ScalarType;

struct WB_ALIGN(4) ListOfBytes;
struct WB_ALIGN(4) ListOfStrings;
struct WB_ALIGN(4) ExecutionContextMetadata;
struct WB_ALIGN(4) ResourceMetadata;
struct WB_ALIGN(4) OperationMetadata;
struct WB_ALIGN(2) ResponseMetadata;
struct WB_ALIGN(2) ParameterMetadata;
struct WB_ALIGN(2) StructurePropertyMetadata;
struct WB_ALIGN(2) EnumerationItemMetadata;
struct WB_ALIGN(4) DataTypeMetadata;
struct WB_ALIGN(2) SecurityTagMetadata;
struct WB_ALIGN(4) StringMetadata;
struct WB_ALIGN(4) WbInfo;
struct WB_ALIGN(4) CommStats;
struct WB_ALIGN(4) ThreadInfo;
struct WB_ALIGN(4) ThreadInfoList;
struct WB_ALIGN(4) RoutingTable;
struct WB_ALIGN(1) CompactWbVersion;
struct WB_ALIGN(4) LaunchableModule;
struct WB_ALIGN(4) LaunchableList;

typedef int8 ThreadPriorityLevel;
typedef uint16 StringId;
typedef uint8 SecurityTagId;
typedef uint8 ResourceInstanceId;
typedef uint16 LocalOperationId;
typedef uint16 LocalResponseId;
typedef uint16 LocalParameterId;
typedef uint16 ScalarUnit;

struct WB_ALIGN(4) ListOfBytes
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 32;

	WB_ALIGN(4) whiteboard::Array< uint8 > items;
};

struct WB_ALIGN(4) ListOfStrings
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 33;

	WB_ALIGN(4) whiteboard::Array< whiteboard::WrapperFor32BitPointer< const char > > items;
};

struct WB_ALIGN(4) ExecutionContextMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 34;

	WB_ALIGN(1) whiteboard::ExecutionContextId id;
	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer< const char > name;
	WB_ALIGN(1) uint8 numberOfDpcs;
	WB_ALIGN(1) uint8 numberOfRequests;
	WB_ALIGN(1) uint8 numberOfResponses;
	WB_ALIGN(2) uint16 stackSize;
	WB_ALIGN(1) ThreadPriority priority;
};

struct WB_ALIGN(4) ResourceMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 35;

	WB_ALIGN(2) whiteboard::LocalResourceId id;
	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer< const char > name;
	WB_ALIGN(1) whiteboard::ExecutionContextId executionContextId;
	WB_ALIGN(4) whiteboard::Array< LocalOperationId > operationIdList;
	WB_ALIGN(2) LocalParameterId pathParameterId;
	WB_ALIGN(2) whiteboard::LocalResourceId parentId;
	WB_ALIGN(2) whiteboard::LocalResourceId nextSiblingId;
	WB_ALIGN(2) whiteboard::LocalResourceId firstChildId;
};

struct WB_ALIGN(4) OperationMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 37;

	WB_ALIGN(2) LocalOperationId id;
	WB_ALIGN(1) OperationType type;
	WB_ALIGN(4) uint32 securityMask;
	WB_ALIGN(4) whiteboard::Array< LocalParameterId > parameterIdList;
	WB_ALIGN(4) whiteboard::Array< LocalResponseId > responseIdList;
};

struct WB_ALIGN(2) ResponseMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 38;

	WB_ALIGN(2) LocalResponseId id;
	WB_ALIGN(2) uint16 code;
	WB_ALIGN(2) whiteboard::LocalDataTypeId dataTypeId;
};

struct WB_ALIGN(2) ParameterMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 39;

	WB_ALIGN(2) LocalParameterId id;
	WB_ALIGN(2) StringId nameId;
	WB_ALIGN(1) bool required;
	WB_ALIGN(2) whiteboard::LocalDataTypeId dataTypeId;
};

struct WB_ALIGN(2) StructurePropertyMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 41;

	WB_ALIGN(2) StringId nameId;
	WB_ALIGN(2) whiteboard::LocalDataTypeId dataTypeId;
	WB_ALIGN(1) bool required;
	WB_ALIGN(1) bool inlineStorage;
};

struct WB_ALIGN(2) EnumerationItemMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 42;

	WB_ALIGN(2) StringId nameId;
	WB_ALIGN(2) int16 value;
};

struct WB_ALIGN(4) DataTypeMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 43;

	WB_ALIGN(2) whiteboard::LocalDataTypeId id;
	WB_ALIGN(1) DataTypeType type;
	WB_ALIGN(1) whiteboard::Optional< ScalarType > scalarType;
	WB_ALIGN(2) whiteboard::Optional< ScalarUnit > scalarUnit;
	WB_ALIGN(2) whiteboard::Optional< StringId > nameId;
	WB_ALIGN(2) whiteboard::Optional< whiteboard::LocalDataTypeId > baseTypeId;
	WB_ALIGN(4) whiteboard::Optional< whiteboard::Array< StructurePropertyMetadata > > properties;
	WB_ALIGN(4) whiteboard::Optional< whiteboard::Array< EnumerationItemMetadata > > items;
};

struct WB_ALIGN(2) SecurityTagMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 44;

	WB_ALIGN(1) SecurityTagId id;
	WB_ALIGN(2) StringId nameId;
};

struct WB_ALIGN(4) StringMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 45;

	WB_ALIGN(2) uint16 id;
	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer< const char > name;
};

struct WB_ALIGN(4) WbInfo
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 256;

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer< const char > version;
	WB_ALIGN(1) uint8 commVersion;
	WB_ALIGN(1) uint8 minCommVersion;
};

struct WB_ALIGN(4) CommStats
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 257;

	WB_ALIGN(4) uint32 sentBytes;
	WB_ALIGN(4) uint32 receivedBytes;
};

struct WB_ALIGN(4) ThreadInfo
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 259;

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer< const char > name;
	WB_ALIGN(1) ThreadState state;
	WB_ALIGN(1) ThreadPriorityLevel basePriority;
	WB_ALIGN(1) ThreadPriorityLevel currentPriority;
	WB_ALIGN(1) uint8 runTimePercentage;
	WB_ALIGN(4) uint32 runTimeTicks;
	WB_ALIGN(4) uint32 contextSwitches;
	WB_ALIGN(4) uint32 freeStack;
	WB_ALIGN(4) uint32 programCounter;
	WB_ALIGN(4) uint32 returnAddress;
};

struct WB_ALIGN(4) ThreadInfoList
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 260;

	WB_ALIGN(4) whiteboard::Array< ThreadInfo > threads;
};

struct WB_ALIGN(4) RoutingTable
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 261;

	WB_ALIGN(1) uint8 version;
	WB_ALIGN(4) ListOfStrings serialNumbers;
};

struct WB_ALIGN(1) CompactWbVersion
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 264;

	WB_ALIGN(1) uint8 majorVersion;
	WB_ALIGN(1) uint8 minorVersion;
	WB_ALIGN(1) uint8 patchVersion;
};

struct WB_ALIGN(4) LaunchableModule
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 267;

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer< const char > name;
	WB_ALIGN(1) ModuleState state;
};

struct WB_ALIGN(4) LaunchableList
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 268;

	WB_ALIGN(4) whiteboard::Array< LaunchableModule > modules;
};

namespace LOCAL 
{

struct ROOT;

struct META;

struct META_DATATYPE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 11, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 11;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const DataTypeMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct TYPEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef TYPEID Parameter1;

			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/DataType */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets TYPEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::TYPEID::ConstReferenceType getTypeId() const
			{
				return mrParameterList[Parameters::TYPEID::Index].convertTo<Parameters::TYPEID::ConstReferenceType>();
			}

			/** Checks whether optional parameter RESOURCEID has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasResourceId() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::RESOURCEID::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::RESOURCEID::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::TYPEID::ConstReferenceType,
			const whiteboard::Api::OptionalParameter<Parameters::RESOURCEID::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};
};

struct META_DATATYPEID
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 15, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 15;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<uint16, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct NAME
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef const char* Type;
				typedef Type ConstReferenceType;
			};

			typedef NAME Parameter1;

			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/DataTypeId */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets NAME parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::NAME::ConstReferenceType getName() const
			{
				return mrParameterList[Parameters::NAME::Index].convertTo<Parameters::NAME::ConstReferenceType>();
			}

			/** Checks whether optional parameter RESOURCEID has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasResourceId() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::RESOURCEID::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::RESOURCEID::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::NAME::ConstReferenceType,
			const whiteboard::Api::OptionalParameter<Parameters::RESOURCEID::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};
};

struct META_EXECUTIONCONTEXT
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 1, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 1;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const ExecutionContextMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct EXECUTIONCONTEXTID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			typedef EXECUTIONCONTEXTID Parameter1;

			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/ExecutionContext */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets EXECUTIONCONTEXTID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::EXECUTIONCONTEXTID::ConstReferenceType getExecutionContextId() const
			{
				return mrParameterList[Parameters::EXECUTIONCONTEXTID::Index].convertTo<Parameters::EXECUTIONCONTEXTID::ConstReferenceType>();
			}

			/** Checks whether optional parameter RESOURCEID has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasResourceId() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::RESOURCEID::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::RESOURCEID::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::EXECUTIONCONTEXTID::ConstReferenceType,
			const whiteboard::Api::OptionalParameter<Parameters::RESOURCEID::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};
};

struct META_HASH
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 14, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 14;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const char*, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct META_METADATASTREAM
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 13, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 13;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::ByteStream&, whiteboard::HTTP_CODE_CONTINUE> HTTP_CODE_CONTINUE;
		typedef whiteboard::StronglyTypedResult<const whiteboard::ByteStream&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_LOCKED> HTTP_CODE_LOCKED;

		struct Parameters
		{
			struct ORIGINALREQUESTID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef ORIGINALREQUESTID Parameter1;

			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/MetadataStream */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Checks whether optional parameter ORIGINALREQUESTID has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasOriginalRequestId() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::ORIGINALREQUESTID::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::ORIGINALREQUESTID::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets ORIGINALREQUESTID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::ORIGINALREQUESTID::ConstReferenceType getOriginalRequestId() const
			{
				return mrParameterList[Parameters::ORIGINALREQUESTID::Index].convertTo<Parameters::ORIGINALREQUESTID::ConstReferenceType>();
			}

			/** Checks whether optional parameter RESOURCEID has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasResourceId() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::RESOURCEID::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::RESOURCEID::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<Parameters::ORIGINALREQUESTID::ConstReferenceType>& = whiteboard::NoType::NoValue,
			const whiteboard::Api::OptionalParameter<Parameters::RESOURCEID::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};
};

struct META_OPERATION
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 6, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 6;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const OperationMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct OPERATIONID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef OPERATIONID Parameter1;

			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Operation */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets OPERATIONID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::OPERATIONID::ConstReferenceType getOperationId() const
			{
				return mrParameterList[Parameters::OPERATIONID::Index].convertTo<Parameters::OPERATIONID::ConstReferenceType>();
			}

			/** Checks whether optional parameter RESOURCEID has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasResourceId() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::RESOURCEID::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::RESOURCEID::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::OPERATIONID::ConstReferenceType,
			const whiteboard::Api::OptionalParameter<Parameters::RESOURCEID::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};
};

struct META_OPERATION_PARAMETER
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 7, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 7;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const ParameterMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct OPERATIONID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef OPERATIONID Parameter1;

			struct PARAMETERINDEX
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			typedef PARAMETERINDEX Parameter2;

			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 2;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter3;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 3;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Operation/Parameter */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets OPERATIONID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::OPERATIONID::ConstReferenceType getOperationId() const
			{
				return mrParameterList[Parameters::OPERATIONID::Index].convertTo<Parameters::OPERATIONID::ConstReferenceType>();
			}

			/** Gets PARAMETERINDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::PARAMETERINDEX::ConstReferenceType getParameterIndex() const
			{
				return mrParameterList[Parameters::PARAMETERINDEX::Index].convertTo<Parameters::PARAMETERINDEX::ConstReferenceType>();
			}

			/** Checks whether optional parameter RESOURCEID has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasResourceId() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::RESOURCEID::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::RESOURCEID::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::OPERATIONID::ConstReferenceType,
			Parameters::PARAMETERINDEX::ConstReferenceType,
			const whiteboard::Api::OptionalParameter<Parameters::RESOURCEID::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};
};

struct META_PARAMETER
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 8, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 8;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const ParameterMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct PARAMETERID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef PARAMETERID Parameter1;

			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Parameter */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets PARAMETERID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::PARAMETERID::ConstReferenceType getParameterId() const
			{
				return mrParameterList[Parameters::PARAMETERID::Index].convertTo<Parameters::PARAMETERID::ConstReferenceType>();
			}

			/** Checks whether optional parameter RESOURCEID has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasResourceId() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::RESOURCEID::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::RESOURCEID::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::PARAMETERID::ConstReferenceType,
			const whiteboard::Api::OptionalParameter<Parameters::RESOURCEID::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};
};

struct META_RESOURCE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 3, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 3;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const ResourceMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Resource */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::RESOURCEID::ConstReferenceType)
		{
		}
	};
};

struct META_RESOURCE_OPERATION
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 4, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 4;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const OperationMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter1;

			struct OPERATIONTYPE
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef OperationType Type;
				typedef Type ConstReferenceType;
			};

			typedef OPERATIONTYPE Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Resource/Operation */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

			/** Gets OPERATIONTYPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::OPERATIONTYPE::ConstReferenceType getOperationType() const
			{
				return mrParameterList[Parameters::OPERATIONTYPE::Index].convertTo<Parameters::OPERATIONTYPE::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::RESOURCEID::ConstReferenceType,
			Parameters::OPERATIONTYPE::ConstReferenceType)
		{
		}
	};
};

struct META_RESOURCE_RESPONSE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 5, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 5;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const ResponseMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter1;

			struct OPERATIONTYPE
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef OperationType Type;
				typedef Type ConstReferenceType;
			};

			typedef OPERATIONTYPE Parameter2;

			struct RESPONSEINDEX
			{
				static const whiteboard::ParameterIndex Index = 2;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESPONSEINDEX Parameter3;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 3;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Resource/Response */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

			/** Gets OPERATIONTYPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::OPERATIONTYPE::ConstReferenceType getOperationType() const
			{
				return mrParameterList[Parameters::OPERATIONTYPE::Index].convertTo<Parameters::OPERATIONTYPE::ConstReferenceType>();
			}

			/** Gets RESPONSEINDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESPONSEINDEX::ConstReferenceType getResponseIndex() const
			{
				return mrParameterList[Parameters::RESPONSEINDEX::Index].convertTo<Parameters::RESPONSEINDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::RESOURCEID::ConstReferenceType,
			Parameters::OPERATIONTYPE::ConstReferenceType,
			Parameters::RESPONSEINDEX::ConstReferenceType)
		{
		}
	};
};

struct META_RESOURCEID
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 2, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 2;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<uint16, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct RESOURCEURI
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef const char* Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEURI Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/ResourceId */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESOURCEURI parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEURI::ConstReferenceType getResourceUri() const
			{
				return mrParameterList[Parameters::RESOURCEURI::Index].convertTo<Parameters::RESOURCEURI::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::RESOURCEURI::ConstReferenceType)
		{
		}
	};
};

struct META_RESPONSE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 9, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 9;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const ResponseMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct RESPONSEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESPONSEID Parameter1;

			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Response */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESPONSEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESPONSEID::ConstReferenceType getResponseId() const
			{
				return mrParameterList[Parameters::RESPONSEID::Index].convertTo<Parameters::RESPONSEID::ConstReferenceType>();
			}

			/** Checks whether optional parameter RESOURCEID has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasResourceId() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::RESOURCEID::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::RESOURCEID::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::RESPONSEID::ConstReferenceType,
			const whiteboard::Api::OptionalParameter<Parameters::RESOURCEID::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};
};

struct META_SECURITYTAG
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 10, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 10;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const SecurityTagMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct SECURITYTAGID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			typedef SECURITYTAGID Parameter1;

			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/SecurityTag */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets SECURITYTAGID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::SECURITYTAGID::ConstReferenceType getSecurityTagId() const
			{
				return mrParameterList[Parameters::SECURITYTAGID::Index].convertTo<Parameters::SECURITYTAGID::ConstReferenceType>();
			}

			/** Checks whether optional parameter RESOURCEID has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasResourceId() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::RESOURCEID::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::RESOURCEID::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::SECURITYTAGID::ConstReferenceType,
			const whiteboard::Api::OptionalParameter<Parameters::RESOURCEID::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};
};

struct META_STRING
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 12, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 12;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const StringMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct STRINGID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef STRINGID Parameter1;

			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/String */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets STRINGID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::STRINGID::ConstReferenceType getStringId() const
			{
				return mrParameterList[Parameters::STRINGID::Index].convertTo<Parameters::STRINGID::ConstReferenceType>();
			}

			/** Checks whether optional parameter RESOURCEID has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasResourceId() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::RESOURCEID::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::RESOURCEID::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::STRINGID::ConstReferenceType,
			const whiteboard::Api::OptionalParameter<Parameters::RESOURCEID::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};
};

struct NET
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 256, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 256;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const RoutingTable&, whiteboard::HTTP_CODE_CONTINUE> HTTP_CODE_CONTINUE;
		typedef whiteboard::StronglyTypedResult<const RoutingTable&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			struct CONTINUATIONINDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint32 Type;
				typedef Type ConstReferenceType;
			};

			typedef CONTINUATIONINDEX Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Net */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Checks whether optional parameter CONTINUATIONINDEX has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasContinuationIndex() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::CONTINUATIONINDEX::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::CONTINUATIONINDEX::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets CONTINUATIONINDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::CONTINUATIONINDEX::ConstReferenceType getContinuationIndex() const
			{
				return mrParameterList[Parameters::CONTINUATIONINDEX::Index].convertTo<Parameters::CONTINUATIONINDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<Parameters::CONTINUATIONINDEX::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};

	struct SUBSCRIBE
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};

	struct EVENT
	{
		typedef const char* NotificationType;
		typedef NotificationType ConstReferenceNotificationType;

		struct Parameters
		{
			struct NOTIFICATIONTYPE
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef RoutingTableNotificationType Type;
				typedef Type ConstReferenceType;
			};

			typedef NOTIFICATIONTYPE Parameter1;

			struct REMOTEWHITEBOARDIDINLOCALSCOPE
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			typedef REMOTEWHITEBOARDIDINLOCALSCOPE Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Net */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets NOTIFICATIONTYPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::NOTIFICATIONTYPE::ConstReferenceType getNotificationType() const
			{
				return mrParameterList[Parameters::NOTIFICATIONTYPE::Index].convertTo<Parameters::NOTIFICATIONTYPE::ConstReferenceType>();
			}

			/** Gets REMOTEWHITEBOARDIDINLOCALSCOPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::ConstReferenceType getRemoteWhiteboardIdInLocalScope() const
			{
				return mrParameterList[Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::Index].convertTo<Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<ConstReferenceNotificationType>&,
			Parameters::NOTIFICATIONTYPE::ConstReferenceType,
			Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::ConstReferenceType)
		{
		}
	};

	struct UNSUBSCRIBE
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct WHITEBOARD;

struct WHITEBOARD_INFO
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 257, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 257;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const WbInfo&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct WHITEBOARD_METRICS;

struct WHITEBOARD_METRICS_COMM
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 258, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 258;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const CommStats&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};

	struct SUBSCRIBE
	{
		typedef whiteboard::StronglyTypedResult<const CommStats&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};

	struct EVENT
	{
		typedef CommStats NotificationType;
		typedef const NotificationType& ConstReferenceNotificationType;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<ConstReferenceNotificationType>&)
		{
		}
	};

	struct UNSUBSCRIBE
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct WHITEBOARD_METRICS_THREADS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 259, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 259;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const ThreadInfoList&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct WHITEBOARD_METRICS_THREADS_COUNT
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 260, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 260;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<uint8, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct WHITEBOARD_METRICS_THREADS_INDEX;

struct WHITEBOARD_METRICS_THREADS_INDEX_NAME
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 261, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 261;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const char*, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_RANGE_NOT_SATISFIABLE> HTTP_CODE_RANGE_NOT_SATISFIABLE;

		struct Parameters
		{
			struct INDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef int32 Type;
				typedef Type ConstReferenceType;
			};

			typedef INDEX Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/Metrics/Threads/{index}/Name */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets INDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::INDEX::ConstReferenceType getIndex() const
			{
				return mrParameterList[Parameters::INDEX::Index].convertTo<Parameters::INDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::INDEX::ConstReferenceType)
		{
		}
	};
};

struct WHITEBOARD_METRICS_THREADS_INDEX_PROGRAMCOUNTER
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 262, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 262;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<uint32, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_RANGE_NOT_SATISFIABLE> HTTP_CODE_RANGE_NOT_SATISFIABLE;

		struct Parameters
		{
			struct INDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef int32 Type;
				typedef Type ConstReferenceType;
			};

			typedef INDEX Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/Metrics/Threads/{index}/ProgramCounter */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets INDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::INDEX::ConstReferenceType getIndex() const
			{
				return mrParameterList[Parameters::INDEX::Index].convertTo<Parameters::INDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::INDEX::ConstReferenceType)
		{
		}
	};
};

struct WHITEBOARD_METRICS_THREADS_INDEX_RETURNADDRESS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 263, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 263;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<uint32, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_RANGE_NOT_SATISFIABLE> HTTP_CODE_RANGE_NOT_SATISFIABLE;

		struct Parameters
		{
			struct INDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef int32 Type;
				typedef Type ConstReferenceType;
			};

			typedef INDEX Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/Metrics/Threads/{index}/ReturnAddress */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets INDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::INDEX::ConstReferenceType getIndex() const
			{
				return mrParameterList[Parameters::INDEX::Index].convertTo<Parameters::INDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::INDEX::ConstReferenceType)
		{
		}
	};
};

struct WHITEBOARD_SYSTEM;

struct WHITEBOARD_SYSTEM_LAUNCHER
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 264, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 264;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const LaunchableList&, whiteboard::HTTP_CODE_CONTINUE> HTTP_CODE_CONTINUE;
		typedef whiteboard::StronglyTypedResult<const LaunchableList&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_RANGE_NOT_SATISFIABLE> HTTP_CODE_RANGE_NOT_SATISFIABLE;

		struct Parameters
		{
			struct MODULESTARTINDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef MODULESTARTINDEX Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/System/Launcher */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Checks whether optional parameter MODULESTARTINDEX has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasModuleStartIndex() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::MODULESTARTINDEX::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::MODULESTARTINDEX::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets MODULESTARTINDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::MODULESTARTINDEX::ConstReferenceType getModuleStartIndex() const
			{
				return mrParameterList[Parameters::MODULESTARTINDEX::Index].convertTo<Parameters::MODULESTARTINDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<Parameters::MODULESTARTINDEX::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};

	struct PUT
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_BAD_REQUEST> HTTP_CODE_BAD_REQUEST;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_BAD_METHOD> HTTP_CODE_BAD_METHOD;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_INTERNAL_SERVER_ERROR> HTTP_CODE_INTERNAL_SERVER_ERROR;

		struct Parameters
		{
			struct NAME
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef const char* Type;
				typedef Type ConstReferenceType;
			};

			typedef NAME Parameter1;

			struct COMMAND
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef ModuleCommand Type;
				typedef Type ConstReferenceType;
			};

			typedef COMMAND Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/System/Launcher */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets NAME parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::NAME::ConstReferenceType getName() const
			{
				return mrParameterList[Parameters::NAME::Index].convertTo<Parameters::NAME::ConstReferenceType>();
			}

			/** Gets COMMAND parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::COMMAND::ConstReferenceType getCommand() const
			{
				return mrParameterList[Parameters::COMMAND::Index].convertTo<Parameters::COMMAND::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::NAME::ConstReferenceType,
			Parameters::COMMAND::ConstReferenceType)
		{
		}
	};
};

struct WHITEBOARD_TEST;

struct WHITEBOARD_TEST_BYPASS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 265, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 265;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const char*, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_BAD_REQUEST> HTTP_CODE_BAD_REQUEST;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_RANGE_NOT_SATISFIABLE> HTTP_CODE_RANGE_NOT_SATISFIABLE;

		struct Parameters
		{
			struct INDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef INDEX Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/Test/Bypass */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets INDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::INDEX::ConstReferenceType getIndex() const
			{
				return mrParameterList[Parameters::INDEX::Index].convertTo<Parameters::INDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::INDEX::ConstReferenceType)
		{
		}
	};

	struct PUT
	{
		typedef whiteboard::StronglyTypedResult<const char*, whiteboard::HTTP_CODE_ACCEPTED> HTTP_CODE_ACCEPTED;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_BAD_REQUEST> HTTP_CODE_BAD_REQUEST;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_PRECOND_FAILED> HTTP_CODE_PRECOND_FAILED;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_IMPLEMENTED> HTTP_CODE_NOT_IMPLEMENTED;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_INSUFFICIENT_STORAGE> HTTP_CODE_INSUFFICIENT_STORAGE;

		struct Parameters
		{
			struct PATHTOBYPASS
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef const char* Type;
				typedef Type ConstReferenceType;
			};

			typedef PATHTOBYPASS Parameter1;

			struct REMOTEPATH
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef const char* Type;
				typedef Type ConstReferenceType;
			};

			typedef REMOTEPATH Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/Test/Bypass */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets PATHTOBYPASS parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::PATHTOBYPASS::ConstReferenceType getPathToBypass() const
			{
				return mrParameterList[Parameters::PATHTOBYPASS::Index].convertTo<Parameters::PATHTOBYPASS::ConstReferenceType>();
			}

			/** Checks whether optional parameter REMOTEPATH has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasRemotePath() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::REMOTEPATH::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::REMOTEPATH::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets REMOTEPATH parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::REMOTEPATH::ConstReferenceType getRemotePath() const
			{
				return mrParameterList[Parameters::REMOTEPATH::Index].convertTo<Parameters::REMOTEPATH::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::PATHTOBYPASS::ConstReferenceType,
			const whiteboard::Api::OptionalParameter<Parameters::REMOTEPATH::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};
};

struct WHITEBOARD_TIME
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 266, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 266;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<int64, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};

	struct SUBSCRIBE
	{
		typedef whiteboard::StronglyTypedResult<int64, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};

	struct EVENT
	{
		typedef int64 NotificationType;
		typedef NotificationType ConstReferenceNotificationType;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<ConstReferenceNotificationType>&)
		{
		}
	};

	struct UNSUBSCRIBE
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};



} // namespace LOCAL 

} // namespace WB_RES
