#pragma once
/***********************************************************************
* THIS FILE HAS BEEN GENERATED BY WBRES TOOL. DO NOT TRY TO CHANGE IT. *
***********************************************************************/

// Copyright (c) Suunto Oy 2014 - 2016. All rights reserved.

#include "whiteboard/Identifiers.h"
#include "whiteboard/ParameterList.h"

#include "whiteboard/builtinTypes/Array.h"
#include "whiteboard/builtinTypes/ByteStream.h"
#include "whiteboard/builtinTypes/Date.h"
#include "whiteboard/builtinTypes/DateTime.h"
#include "whiteboard/builtinTypes/Optional.h"
#include "whiteboard/builtinTypes/Structures.h"
#include "whiteboard/builtinTypes/Time.h"
#include "whiteboard/builtinTypes/Timestamp.h"
#include "whiteboard/builtinTypes/TypedEnum.h"
#include "whiteboard/builtinTypes/Vector2D.h"
#include "whiteboard/builtinTypes/Vector3D.h"
#include "whiteboard/builtinTypes/WrapperFor32BitPointer.h"

#define WB_EXECUTION_CONTEXT_INSTANTION_REF(id)						static_cast<whiteboard::ExecutionContextId>(id)
#define WB_RESOURCE_VALUE(whiteboardId, localResourceId, executionContextId) \
	static_cast<whiteboard::ResourceId::Value>( \
		(static_cast<uint32>(localResourceId) << 16) | \
		(static_cast<uint32>(whiteboardId) << 8) | \
		(static_cast<uint32>(executionContextId) << 4) | \
		(static_cast<uint32>(whiteboard::ID_INVALID_RESOURCE_INSTANCE)))

#define WB_CALLER_CONTEXT										whiteboard::ID_INVALID_EXECUTION_CONTEXT


/** Helper function for force linking of the library
* (Visual C will ignore whole library if none of the symbols are referenced)
*/
void pullInWbResources();

#define WB_EXEC_CTX_PRIMARYSERVICES              WB_EXECUTION_CONTEXT_INSTANTION_REF(0)
#define WB_EXEC_CTX_APPLICATION                  WB_EXECUTION_CONTEXT_INSTANTION_REF(1)

namespace WB_RES {

WB_STRUCT_PACK_BEGIN()

struct AdapterStateValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 268;

	enum Type
	{
		ADAPTER_DISABLED = 0U,
		ADAPTER_ENABLED = 1U,
		ADAPTER_ERROR = 2U
	};
};
typedef whiteboard::TypedEnum<AdapterStateValues, AdapterStateValues::Type, uint8> AdapterState;

struct RouteStateValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 265;

	enum Type
	{
		ROUTE_STATE_NOT_USED = 0U,
		ROUTE_STATE_ADAPTER_DISABLED = 1U,
		ROUTE_STATE_NOT_CONNECTED = 2U,
		ROUTE_STATE_CONNECTING = 3U,
		ROUTE_STATE_HANDSHAKING = 4U,
		ROUTE_STATE_ESTABLISHED = 5U,
		ROUTE_STATE_DISCONNECTING = 6U,
		ROUTE_STATE_ERROR = 7U
	};
};
typedef whiteboard::TypedEnum<RouteStateValues, RouteStateValues::Type, uint8> RouteState;

struct RoutingTableNotificationTypeValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 270;

	enum Type
	{
		ROUTE_NOTIFICATION_NEW = 0U,
		ROUTE_NOTIFICATION_LOST = 1U,
		ROUTE_NOTIFICATION_ERROR = 2U
	};
};
typedef whiteboard::TypedEnum<RoutingTableNotificationTypeValues, RoutingTableNotificationTypeValues::Type, uint8> RoutingTableNotificationType;

struct ModuleCommandValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 271;

	enum Type
	{
		INITIALIZE = 0U,
		START = 1U,
		STOP = 2U,
		DEINITIALIZE = 3U
	};
};
typedef whiteboard::TypedEnum<ModuleCommandValues, ModuleCommandValues::Type, uint8> ModuleCommand;

struct ModuleStateValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 272;

	enum Type
	{
		UNINITIALIZED = 0U,
		INITIALIZED = 1U,
		STARTED = 2U,
		STOPPED = 3U,
		INITFAILED = 4U,
		FAILURE = 5U
	};
};
typedef whiteboard::TypedEnum<ModuleStateValues, ModuleStateValues::Type, uint8> ModuleState;

struct ThreadPriorityValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 276;

	enum Type
	{
		NOT_AVAILABLE = 0U,
		LOW = 1U,
		NORMAL = 2U,
		HIGH = 3U
	};
};
typedef whiteboard::TypedEnum<ThreadPriorityValues, ThreadPriorityValues::Type, uint8> ThreadPriority;

struct OperationTypeValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 36;

	enum Type
	{
		GET = 0U,
		PUT = 1U,
		POST = 2U,
		DELETE = 3U,
		EVENT = 4U
	};
};
typedef whiteboard::TypedEnum<OperationTypeValues, OperationTypeValues::Type, uint8> OperationType;

struct DataTypeTypeValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 40;

	enum Type
	{
		SCALAR = 0U,
		NAMED = 1U,
		ARRAY = 2U,
		STRUCTURE = 3U,
		ENUMERATION = 4U
	};
};
typedef whiteboard::TypedEnum<DataTypeTypeValues, DataTypeTypeValues::Type, uint8> DataTypeType;

struct ScalarTypeValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 277;

	enum Type
	{
		NONE = 0U,
		BOOL = 1U,
		INT8 = 2U,
		UINT8 = 3U,
		INT16 = 4U,
		UINT16 = 5U,
		INT32 = 6U,
		UINT32 = 7U,
		INT64 = 8U,
		UINT64 = 9U,
		FLOAT = 10U,
		DOUBLE = 11U,
		STRING = 12U,
		LIST_OF_BYTES = 13U,
		BYTE_STREAM = 14U,
		LIST_OF_STRINGS = 15U,
		STRUCTURE = 16U
	};
};
typedef whiteboard::TypedEnum<ScalarTypeValues, ScalarTypeValues::Type, uint8> ScalarType;

struct ScalarUnitValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 278;

	enum Type
	{
		METERS_PER_SECOND_SQUARED = 0U,
		GRAVITY_OF_EARTH = 1U,
		RADIAN = 256U,
		DEGREE = 257U,
		RADIANS_PER_SECOND = 512U,
		DEGREES_PER_SECOND = 513U,
		METER = 768U,
		FOOT = 769U,
		YARD = 770U,
		MILE = 771U,
		AMPERE = 1024U,
		MILLIAMPERE = 1025U,
		VOLT = 1280U,
		JOULE = 1536U,
		NEWTON = 1792U,
		HERTZ = 2048U,
		KILOHERTZ = 2049U,
		MEGAHERTZ = 2050U,
		LUX = 2304U,
		TESLA = 2560U,
		MILLITESLA = 2561U,
		MICROTESLA = 2562U,
		KILOGRAM = 2816U,
		POUND = 2817U,
		SCALAR = 3072U,
		PERCENT = 3073U,
		WATT = 3328U,
		PASCAL = 3584U,
		BAR = 3585U,
		MILLIBAR = 3586U,
		PSI = 3587U,
		METERS_PER_SECOND = 3840U,
		METERS_PER_MINUTE = 3841U,
		KILOMETERS_PER_HOUR = 3842U,
		MILES_PER_HOUR = 3843U,
		KELVIN = 4096U,
		CELCIUS = 4097U,
		FAHRENHEIT = 4098U,
		SECOND = 4352U,
		MINUTE = 4353U,
		HOUR = 4354U,
		DAY = 4355U,
		MILLISECOND = 4356U,
		MICROSECOND = 4357U
	};
};
typedef whiteboard::TypedEnum<ScalarUnitValues, ScalarUnitValues::Type, uint16> ScalarUnit;

struct WB_STRUCT_PACKED ListOfBytes;
struct WB_STRUCT_PACKED ListOfStrings;
struct WB_STRUCT_PACKED ExecutionContextMetadata;
struct WB_STRUCT_PACKED ResourceMetadata;
struct WB_STRUCT_PACKED OperationMetadata;
struct WB_STRUCT_PACKED ResponseMetadata;
struct WB_STRUCT_PACKED ParameterMetadata;
struct WB_STRUCT_PACKED StructurePropertyMetadata;
struct WB_STRUCT_PACKED EnumerationItemMetadata;
struct WB_STRUCT_PACKED DataTypeMetadata;
struct WB_STRUCT_PACKED SecurityTagMetadata;
struct WB_STRUCT_PACKED StringMetadata;
struct WB_STRUCT_PACKED WbInfo;
struct WB_STRUCT_PACKED PoolStats;
struct WB_STRUCT_PACKED PoolStatsList;
struct WB_STRUCT_PACKED EventQueueInfo;
struct WB_STRUCT_PACKED EventQueueInfoList;
struct WB_STRUCT_PACKED BlockingObjectPoolStats;
struct WB_STRUCT_PACKED BlockingObjectPoolStatsList;
struct WB_STRUCT_PACKED SubscriptionInfo;
struct WB_STRUCT_PACKED SubscriptionList;
struct WB_STRUCT_PACKED CompactWbVersion;
struct WB_STRUCT_PACKED RoutingTableEntry;
struct WB_STRUCT_PACKED RoutingTable;
struct WB_STRUCT_PACKED LaunchableModule;
struct WB_STRUCT_PACKED LaunchableList;

typedef uint16 StringId;
typedef uint8 SecurityTagId;
typedef uint8 ResourceInstanceId;
typedef uint16 LocalOperationId;
typedef uint16 LocalResponseId;
typedef uint16 LocalParameterId;

struct WB_STRUCT_PACKED ListOfBytes
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 32;
	static const whiteboard::StructureValueSerializer<ListOfBytes> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<ListOfBytes> cleaner;)

	WB_ALIGN(4) whiteboard::Array< uint8 > items;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(items);
	}
};

struct WB_STRUCT_PACKED ListOfStrings
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 33;
	static const whiteboard::StructureValueSerializer<ListOfStrings> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<ListOfStrings> cleaner;)

	WB_ALIGN(4) whiteboard::Array< whiteboard::WrapperFor32BitPointer<const char> > items;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(items);
	}
};

struct WB_STRUCT_PACKED ExecutionContextMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 34;
	static const whiteboard::StructureValueSerializer<ExecutionContextMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<ExecutionContextMetadata> cleaner;)

	WB_ALIGN(1) whiteboard::ExecutionContextId id;
	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> name;
	WB_ALIGN(1) uint8 numberOfDpcs;
	WB_ALIGN(1) uint8 numberOfRequests;
	WB_ALIGN(1) uint8 numberOfResponses;
	WB_ALIGN(2) uint16 stackSize;
	WB_ALIGN(1) ThreadPriority priority;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(name)
			.visit(numberOfDpcs)
			.visit(numberOfRequests)
			.visit(numberOfResponses)
			.visit(stackSize)
			.visit(priority);
	}
};

struct WB_STRUCT_PACKED ResourceMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 35;
	static const whiteboard::StructureValueSerializer<ResourceMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<ResourceMetadata> cleaner;)

	WB_ALIGN(2) whiteboard::LocalResourceId id;
	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> name;
	WB_ALIGN(1) whiteboard::ExecutionContextId executionContextId;
	WB_ALIGN(4) whiteboard::Array< LocalOperationId > operationIdList;
	WB_ALIGN(2) LocalParameterId pathParameterId;
	WB_ALIGN(2) whiteboard::LocalResourceId parentId;
	WB_ALIGN(2) whiteboard::LocalResourceId nextSiblingId;
	WB_ALIGN(2) whiteboard::LocalResourceId firstChildId;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(name)
			.visit(executionContextId)
			.visit(operationIdList)
			.visit(pathParameterId)
			.visit(parentId)
			.visit(nextSiblingId)
			.visit(firstChildId);
	}
};

struct WB_STRUCT_PACKED OperationMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 37;
	static const whiteboard::StructureValueSerializer<OperationMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<OperationMetadata> cleaner;)

	WB_ALIGN(2) LocalOperationId id;
	WB_ALIGN(1) OperationType type;
	WB_ALIGN(4) uint32 securityMask;
	WB_ALIGN(4) whiteboard::Array< LocalParameterId > parameterIdList;
	WB_ALIGN(4) whiteboard::Array< LocalResponseId > responseIdList;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(type)
			.visit(securityMask)
			.visit(parameterIdList)
			.visit(responseIdList);
	}
};

struct WB_STRUCT_PACKED ResponseMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 38;
	static const whiteboard::StructureValueSerializer<ResponseMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<ResponseMetadata> cleaner;)

	WB_ALIGN(2) LocalResponseId id;
	WB_ALIGN(2) uint16 code;
	WB_ALIGN(2) whiteboard::LocalDataTypeId dataTypeId;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(code)
			.visit(dataTypeId);
	}
};

struct WB_STRUCT_PACKED ParameterMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 39;
	static const whiteboard::StructureValueSerializer<ParameterMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<ParameterMetadata> cleaner;)

	WB_ALIGN(2) LocalParameterId id;
	WB_ALIGN(2) StringId nameId;
	WB_ALIGN(1) bool required;
	WB_ALIGN(2) whiteboard::LocalDataTypeId dataTypeId;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(nameId)
			.visit(required)
			.visit(dataTypeId);
	}
};

struct WB_STRUCT_PACKED StructurePropertyMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 41;
	static const whiteboard::StructureValueSerializer<StructurePropertyMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<StructurePropertyMetadata> cleaner;)

	WB_ALIGN(2) StringId nameId;
	WB_ALIGN(2) whiteboard::LocalDataTypeId dataTypeId;
	WB_ALIGN(1) bool required;
	WB_ALIGN(1) bool inlineStorage;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(nameId)
			.visit(dataTypeId)
			.visit(required)
			.visit(inlineStorage);
	}
};

struct WB_STRUCT_PACKED EnumerationItemMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 42;
	static const whiteboard::StructureValueSerializer<EnumerationItemMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<EnumerationItemMetadata> cleaner;)

	WB_ALIGN(2) StringId nameId;
	WB_ALIGN(2) int16 value;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(nameId)
			.visit(value);
	}
};

struct WB_STRUCT_PACKED DataTypeMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 43;
	static const whiteboard::StructureValueSerializer<DataTypeMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<DataTypeMetadata> cleaner;)

	WB_ALIGN(2) whiteboard::LocalDataTypeId id;
	WB_ALIGN(1) DataTypeType type;
	WB_ALIGN(1) whiteboard::Optional< ScalarType > scalarType;
	WB_ALIGN(2) whiteboard::Optional< ScalarUnit > scalarUnit;
	WB_ALIGN(2) whiteboard::Optional< StringId > nameId;
	WB_ALIGN(2) whiteboard::Optional< whiteboard::LocalDataTypeId > baseTypeId;
	WB_ALIGN(4) whiteboard::Optional< whiteboard::Array< StructurePropertyMetadata > > properties;
	WB_ALIGN(4) whiteboard::Optional< whiteboard::Array< EnumerationItemMetadata > > items;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(type)
			.visit(scalarType)
			.visit(scalarUnit)
			.visit(nameId)
			.visit(baseTypeId)
			.visit(properties)
			.visit(items);
	}
};

struct WB_STRUCT_PACKED SecurityTagMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 44;
	static const whiteboard::StructureValueSerializer<SecurityTagMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<SecurityTagMetadata> cleaner;)

	WB_ALIGN(1) SecurityTagId id;
	WB_ALIGN(2) StringId nameId;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(nameId);
	}
};

struct WB_STRUCT_PACKED StringMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 45;
	static const whiteboard::StructureValueSerializer<StringMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<StringMetadata> cleaner;)

	WB_ALIGN(2) uint16 id;
	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> name;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(name);
	}
};

struct WB_STRUCT_PACKED WbInfo
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 256;
	static const whiteboard::StructureValueSerializer<WbInfo> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<WbInfo> cleaner;)

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> version;
	WB_ALIGN(1) uint8 commVersion;
	WB_ALIGN(1) uint8 minCommVersion;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(version)
			.visit(commVersion)
			.visit(minCommVersion);
	}
};

struct WB_STRUCT_PACKED PoolStats
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 257;
	static const whiteboard::StructureValueSerializer<PoolStats> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<PoolStats> cleaner;)

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> name;
	WB_ALIGN(2) uint16 size;
	WB_ALIGN(2) uint16 allocated;
	WB_ALIGN(2) uint16 highWaterMark;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(name)
			.visit(size)
			.visit(allocated)
			.visit(highWaterMark);
	}
};

struct WB_STRUCT_PACKED PoolStatsList
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 258;
	static const whiteboard::StructureValueSerializer<PoolStatsList> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<PoolStatsList> cleaner;)

	WB_ALIGN(4) whiteboard::Array< PoolStats > pools;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(pools);
	}
};

struct WB_STRUCT_PACKED EventQueueInfo
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 259;
	static const whiteboard::StructureValueSerializer<EventQueueInfo> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<EventQueueInfo> cleaner;)

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> name;
	WB_ALIGN(4) uint32 size;
	WB_ALIGN(4) uint32 used;
	WB_ALIGN(4) uint32 total;
	WB_ALIGN(4) uint32 highWaterMark;
	WB_ALIGN(4) uint32 slow;
	WB_ALIGN(4) uint32 verySlow;
	WB_ALIGN(4) uint32 failed;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(name)
			.visit(size)
			.visit(used)
			.visit(total)
			.visit(highWaterMark)
			.visit(slow)
			.visit(verySlow)
			.visit(failed);
	}
};

struct WB_STRUCT_PACKED EventQueueInfoList
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 260;
	static const whiteboard::StructureValueSerializer<EventQueueInfoList> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<EventQueueInfoList> cleaner;)

	WB_ALIGN(4) whiteboard::Array< EventQueueInfo > queues;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(queues);
	}
};

struct WB_STRUCT_PACKED BlockingObjectPoolStats
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 261;
	static const whiteboard::StructureValueSerializer<BlockingObjectPoolStats> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<BlockingObjectPoolStats> cleaner;)

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> name;
	WB_ALIGN(2) uint16 size;
	WB_ALIGN(4) uint32 allocated;
	WB_ALIGN(4) uint32 highWaterMark;
	WB_ALIGN(4) uint32 allocations;
	WB_ALIGN(4) uint32 emptyCount;
	WB_ALIGN(4) uint32 emptyTimeMs;
	WB_ALIGN(4) uint32 blockTimeMs;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(name)
			.visit(size)
			.visit(allocated)
			.visit(highWaterMark)
			.visit(allocations)
			.visit(emptyCount)
			.visit(emptyTimeMs)
			.visit(blockTimeMs);
	}
};

struct WB_STRUCT_PACKED BlockingObjectPoolStatsList
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 262;
	static const whiteboard::StructureValueSerializer<BlockingObjectPoolStatsList> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<BlockingObjectPoolStatsList> cleaner;)

	WB_ALIGN(4) whiteboard::Array< BlockingObjectPoolStats > pools;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(pools);
	}
};

struct WB_STRUCT_PACKED SubscriptionInfo
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 263;
	static const whiteboard::StructureValueSerializer<SubscriptionInfo> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<SubscriptionInfo> cleaner;)

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> name;
	WB_ALIGN(2) uint16 localClientId;
	WB_ALIGN(4) whiteboard::Array< int32 > pathParams;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(name)
			.visit(localClientId)
			.visit(pathParams);
	}
};

struct WB_STRUCT_PACKED SubscriptionList
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 264;
	static const whiteboard::StructureValueSerializer<SubscriptionList> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<SubscriptionList> cleaner;)

	WB_ALIGN(4) whiteboard::Array< SubscriptionInfo > subscriptions;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(subscriptions);
	}
};

struct WB_STRUCT_PACKED CompactWbVersion
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 266;
	static const whiteboard::StructureValueSerializer<CompactWbVersion> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<CompactWbVersion> cleaner;)

	WB_ALIGN(1) uint8 majorVersion;
	WB_ALIGN(1) uint8 minorVersion;
	WB_ALIGN(1) uint8 patchVersion;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(majorVersion)
			.visit(minorVersion)
			.visit(patchVersion);
	}
};

struct WB_STRUCT_PACKED RoutingTableEntry
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 267;
	static const whiteboard::StructureValueSerializer<RoutingTableEntry> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<RoutingTableEntry> cleaner;)

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> serialNumber;
	WB_ALIGN(1) uint8 entryVersion;
	WB_ALIGN(1) uint8 sequenceNumber;
	WB_ALIGN(1) uint8 numberOfHops;
	WB_ALIGN(1) RouteState routeState;
	WB_ALIGN(4) int32 routeStateTimeout;
	WB_ALIGN(4) int32 lastMessageSent;
	WB_ALIGN(4) int32 lifetime;
	WB_ALIGN(1) uint8 protocolVersion;
	WB_ALIGN(1) CompactWbVersion wbVersion;
	WB_ALIGN(1) uint8 remoteWhiteboardIdInLocalScope;
	WB_ALIGN(1) uint8 localWhiteboardIdInRemoteScope;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(serialNumber)
			.visit(entryVersion)
			.visit(sequenceNumber)
			.visit(numberOfHops)
			.visit(routeState)
			.visit(routeStateTimeout)
			.visit(lastMessageSent)
			.visit(lifetime)
			.visit(protocolVersion)
			.visit(wbVersion)
			.visit(remoteWhiteboardIdInLocalScope)
			.visit(localWhiteboardIdInRemoteScope);
	}
};

struct WB_STRUCT_PACKED RoutingTable
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 269;
	static const whiteboard::StructureValueSerializer<RoutingTable> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<RoutingTable> cleaner;)

	WB_ALIGN(1) uint8 version;
	WB_ALIGN(4) ListOfStrings serialNumbers;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(version)
			.visit(serialNumbers);
	}
};

struct WB_STRUCT_PACKED LaunchableModule
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 273;
	static const whiteboard::StructureValueSerializer<LaunchableModule> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<LaunchableModule> cleaner;)

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> name;
	WB_ALIGN(1) ModuleState state;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(name)
			.visit(state);
	}
};

struct WB_STRUCT_PACKED LaunchableList
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 274;
	static const whiteboard::StructureValueSerializer<LaunchableList> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<LaunchableList> cleaner;)

	WB_ALIGN(4) whiteboard::Array< LaunchableModule > modules;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(modules);
	}
};

WB_STRUCT_PACK_END()

namespace LOCAL
{

struct ROOT;

struct META;

struct META_DATATYPE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 11, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 11;

	struct GET
	{
		typedef DataTypeMetadata Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct TYPEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/DataType */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets TYPEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::TYPEID::ConstReferenceType getTypeId() const
			{
				return mrParameterList[Parameters::TYPEID::Index].convertTo<Parameters::TYPEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct META_EXECUTIONCONTEXT
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 1, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 1;

	struct GET
	{
		typedef ExecutionContextMetadata Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct EXECUTIONCONTEXTID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/ExecutionContext */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets EXECUTIONCONTEXTID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::EXECUTIONCONTEXTID::ConstReferenceType getExecutionContextId() const
			{
				return mrParameterList[Parameters::EXECUTIONCONTEXTID::Index].convertTo<Parameters::EXECUTIONCONTEXTID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct META_HASH
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 14, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 14;

	struct GET
	{
		typedef const char* Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};
	};
};

struct META_METADATASTREAM
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 13, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 13;

	struct GET
	{
		typedef whiteboard::ByteStream Response_HTTP_CODE_CONTINUE_Type;
		typedef whiteboard::ByteStream Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct ORIGINALREQUESTID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/MetadataStream */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Checks whether optional parameter ORIGINALREQUESTID has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasOriginalRequestId() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::ORIGINALREQUESTID::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::ORIGINALREQUESTID::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets ORIGINALREQUESTID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::ORIGINALREQUESTID::ConstReferenceType getOriginalRequestId() const
			{
				return mrParameterList[Parameters::ORIGINALREQUESTID::Index].convertTo<Parameters::ORIGINALREQUESTID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct META_OPERATION
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 6, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 6;

	struct GET
	{
		typedef OperationMetadata Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct OPERATIONID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Operation */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets OPERATIONID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::OPERATIONID::ConstReferenceType getOperationId() const
			{
				return mrParameterList[Parameters::OPERATIONID::Index].convertTo<Parameters::OPERATIONID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct META_OPERATION_PARAMETER
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 7, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 7;

	struct GET
	{
		typedef ParameterMetadata Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct OPERATIONID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			struct PARAMETERINDEX
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Operation/Parameter */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets OPERATIONID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::OPERATIONID::ConstReferenceType getOperationId() const
			{
				return mrParameterList[Parameters::OPERATIONID::Index].convertTo<Parameters::OPERATIONID::ConstReferenceType>();
			}

			/** Gets PARAMETERINDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::PARAMETERINDEX::ConstReferenceType getParameterIndex() const
			{
				return mrParameterList[Parameters::PARAMETERINDEX::Index].convertTo<Parameters::PARAMETERINDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct META_PARAMETER
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 8, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 8;

	struct GET
	{
		typedef ParameterMetadata Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct PARAMETERID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Parameter */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets PARAMETERID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::PARAMETERID::ConstReferenceType getParameterId() const
			{
				return mrParameterList[Parameters::PARAMETERID::Index].convertTo<Parameters::PARAMETERID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct META_RESOURCE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 3, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 3;

	struct GET
	{
		typedef ResourceMetadata Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Resource */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct META_RESOURCE_OPERATION
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 4, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 4;

	struct GET
	{
		typedef OperationMetadata Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			struct OPERATIONTYPE
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef OperationType Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Resource/Operation */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

			/** Gets OPERATIONTYPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::OPERATIONTYPE::ConstReferenceType getOperationType() const
			{
				return mrParameterList[Parameters::OPERATIONTYPE::Index].convertTo<Parameters::OPERATIONTYPE::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct META_RESOURCE_RESPONSE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 5, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 5;

	struct GET
	{
		typedef ResponseMetadata Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			struct OPERATIONTYPE
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef OperationType Type;
				typedef Type ConstReferenceType;
			};

			struct RESPONSEINDEX
			{
				static const whiteboard::ParameterIndex Index = 2;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 3;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Resource/Response */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

			/** Gets OPERATIONTYPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::OPERATIONTYPE::ConstReferenceType getOperationType() const
			{
				return mrParameterList[Parameters::OPERATIONTYPE::Index].convertTo<Parameters::OPERATIONTYPE::ConstReferenceType>();
			}

			/** Gets RESPONSEINDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESPONSEINDEX::ConstReferenceType getResponseIndex() const
			{
				return mrParameterList[Parameters::RESPONSEINDEX::Index].convertTo<Parameters::RESPONSEINDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct META_RESOURCEID
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 2, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 2;

	struct GET
	{
		typedef uint16 Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct RESOURCEURI
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef const char* Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/ResourceId */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESOURCEURI parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEURI::ConstReferenceType getResourceUri() const
			{
				return mrParameterList[Parameters::RESOURCEURI::Index].convertTo<Parameters::RESOURCEURI::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct META_RESPONSE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 9, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 9;

	struct GET
	{
		typedef ResponseMetadata Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct RESPONSEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Response */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESPONSEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESPONSEID::ConstReferenceType getResponseId() const
			{
				return mrParameterList[Parameters::RESPONSEID::Index].convertTo<Parameters::RESPONSEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct META_SECURITYTAG
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 10, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 10;

	struct GET
	{
		typedef SecurityTagMetadata Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct SECURITYTAGID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/SecurityTag */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets SECURITYTAGID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::SECURITYTAGID::ConstReferenceType getSecurityTagId() const
			{
				return mrParameterList[Parameters::SECURITYTAGID::Index].convertTo<Parameters::SECURITYTAGID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct META_STRING
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 12, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 12;

	struct GET
	{
		typedef StringMetadata Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct STRINGID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/String */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets STRINGID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::STRINGID::ConstReferenceType getStringId() const
			{
				return mrParameterList[Parameters::STRINGID::Index].convertTo<Parameters::STRINGID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct NET
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 256, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 256;

	struct GET
	{
		typedef RoutingTable Response_HTTP_CODE_CONTINUE_Type;
		typedef RoutingTable Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct CONTINUATIONINDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint32 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Net */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Checks whether optional parameter CONTINUATIONINDEX has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasContinuationIndex() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::CONTINUATIONINDEX::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::CONTINUATIONINDEX::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets CONTINUATIONINDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::CONTINUATIONINDEX::ConstReferenceType getContinuationIndex() const
			{
				return mrParameterList[Parameters::CONTINUATIONINDEX::Index].convertTo<Parameters::CONTINUATIONINDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};

	struct SUBSCRIBE
	{
		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};
	};

	struct EVENT
	{
		typedef const char* NotificationType;
	};

	struct UNSUBSCRIBE
	{
		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};
	};
};

struct NET_ADAPTER;

struct NET_ADAPTER_INDEX;

struct NET_ADAPTER_INDEX_NAME
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 257, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 257;

	struct GET
	{
		typedef const char* Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct INDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef int32 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Net/Adapter/{index}/Name */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets INDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::INDEX::ConstReferenceType getIndex() const
			{
				return mrParameterList[Parameters::INDEX::Index].convertTo<Parameters::INDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct NET_ADAPTER_INDEX_STATE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 258, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 258;

	struct GET
	{
		typedef AdapterState Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct INDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef int32 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Net/Adapter/{index}/State */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets INDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::INDEX::ConstReferenceType getIndex() const
			{
				return mrParameterList[Parameters::INDEX::Index].convertTo<Parameters::INDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct NET_INFO
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 259, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 259;

	struct GET
	{
		typedef RoutingTableEntry Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct REMOTEWHITEBOARDIDINLOCALSCOPE
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Net/Info */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets REMOTEWHITEBOARDIDINLOCALSCOPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::ConstReferenceType getRemoteWhiteboardIdInLocalScope() const
			{
				return mrParameterList[Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::Index].convertTo<Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct NET_INFO_REMOTEWHITEBOARDIDINLOCALSCOPE;

struct NET_INFO_REMOTEWHITEBOARDIDINLOCALSCOPE_ADDRESS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 260, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 260;

	struct GET
	{
		typedef const char* Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct REMOTEWHITEBOARDIDINLOCALSCOPE
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef int32 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Net/Info/{remoteWhiteboardIdInLocalScope}/Address */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets REMOTEWHITEBOARDIDINLOCALSCOPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::ConstReferenceType getRemoteWhiteboardIdInLocalScope() const
			{
				return mrParameterList[Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::Index].convertTo<Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct NET_INFO_REMOTEWHITEBOARDIDINLOCALSCOPE_SERIALNUMBER
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 261, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 261;

	struct GET
	{
		typedef const char* Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct REMOTEWHITEBOARDIDINLOCALSCOPE
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef int32 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Net/Info/{remoteWhiteboardIdInLocalScope}/SerialNumber */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets REMOTEWHITEBOARDIDINLOCALSCOPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::ConstReferenceType getRemoteWhiteboardIdInLocalScope() const
			{
				return mrParameterList[Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::Index].convertTo<Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct NET_INFO_REMOTEWHITEBOARDIDINLOCALSCOPE_STATE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 262, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 262;

	struct GET
	{
		typedef RouteState Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct REMOTEWHITEBOARDIDINLOCALSCOPE
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef int32 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Net/Info/{remoteWhiteboardIdInLocalScope}/State */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets REMOTEWHITEBOARDIDINLOCALSCOPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::ConstReferenceType getRemoteWhiteboardIdInLocalScope() const
			{
				return mrParameterList[Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::Index].convertTo<Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct WHITEBOARD;

struct WHITEBOARD_INFO
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 263, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 263;

	struct GET
	{
		typedef WbInfo Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};
	};
};

struct WHITEBOARD_INFO_SUBSCRIPTIONS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 264, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 264;

	struct GET
	{
		typedef SubscriptionList Response_HTTP_CODE_CONTINUE_Type;
		typedef SubscriptionList Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct RESOURCEPATH
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef const char* Type;
				typedef Type ConstReferenceType;
			};

			struct STARTINDEX
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint32 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/Info/Subscriptions */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESOURCEPATH parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEPATH::ConstReferenceType getResourcePath() const
			{
				return mrParameterList[Parameters::RESOURCEPATH::Index].convertTo<Parameters::RESOURCEPATH::ConstReferenceType>();
			}

			/** Checks whether optional parameter STARTINDEX has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasStartIndex() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::STARTINDEX::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::STARTINDEX::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets STARTINDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::STARTINDEX::ConstReferenceType getStartIndex() const
			{
				return mrParameterList[Parameters::STARTINDEX::Index].convertTo<Parameters::STARTINDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct WHITEBOARD_METRICS;

struct WHITEBOARD_METRICS_BLOCKINGOBJECTPOOLS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 265, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 265;

	struct GET
	{
		typedef BlockingObjectPoolStatsList Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};
	};
};

struct WHITEBOARD_METRICS_EVENTS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 266, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 266;

	struct GET
	{
		typedef EventQueueInfoList Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct TYPE
			{
				static const whiteboard::ParameterIndex Index = 0;

				struct TypeValues
				{
					static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 279;
				
					enum Type
					{
						REQUESTS = 0U,
						RESPONSES = 1U
					};
				};
				typedef whiteboard::TypedEnum<TypeValues, TypeValues::Type, uint8> Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/Metrics/Events */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Checks whether optional parameter TYPE has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasType() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::TYPE::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::TYPE::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets TYPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::TYPE::ConstReferenceType getType() const
			{
				return mrParameterList[Parameters::TYPE::Index].convertTo<Parameters::TYPE::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct WHITEBOARD_METRICS_POOLS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 267, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 267;

	struct GET
	{
		typedef PoolStatsList Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};
	};
};

struct WHITEBOARD_SYSTEM;

struct WHITEBOARD_SYSTEM_LAUNCHER
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 268, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 268;

	struct GET
	{
		typedef LaunchableList Response_HTTP_CODE_CONTINUE_Type;
		typedef LaunchableList Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct MODULESTARTINDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/System/Launcher */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Checks whether optional parameter MODULESTARTINDEX has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasModuleStartIndex() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::MODULESTARTINDEX::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::MODULESTARTINDEX::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets MODULESTARTINDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::MODULESTARTINDEX::ConstReferenceType getModuleStartIndex() const
			{
				return mrParameterList[Parameters::MODULESTARTINDEX::Index].convertTo<Parameters::MODULESTARTINDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};

	struct PUT
	{
		struct Parameters
		{
			struct NAME
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef const char* Type;
				typedef Type ConstReferenceType;
			};

			struct COMMAND
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef ModuleCommand Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/System/Launcher */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets NAME parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::NAME::ConstReferenceType getName() const
			{
				return mrParameterList[Parameters::NAME::Index].convertTo<Parameters::NAME::ConstReferenceType>();
			}

			/** Gets COMMAND parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::COMMAND::ConstReferenceType getCommand() const
			{
				return mrParameterList[Parameters::COMMAND::Index].convertTo<Parameters::COMMAND::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct WHITEBOARD_TEST;

struct WHITEBOARD_TEST_BYPASS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 269, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 269;

	struct GET
	{
		typedef const char* Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct INDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/Test/Bypass */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets INDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::INDEX::ConstReferenceType getIndex() const
			{
				return mrParameterList[Parameters::INDEX::Index].convertTo<Parameters::INDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};

	struct PUT
	{
		typedef const char* Response_HTTP_CODE_ACCEPTED_Type;

		struct Parameters
		{
			struct PATHTOBYPASS
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef const char* Type;
				typedef Type ConstReferenceType;
			};

			struct REMOTEPATH
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef const char* Type;
				typedef Type ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/Test/Bypass */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets PATHTOBYPASS parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::PATHTOBYPASS::ConstReferenceType getPathToBypass() const
			{
				return mrParameterList[Parameters::PATHTOBYPASS::Index].convertTo<Parameters::PATHTOBYPASS::ConstReferenceType>();
			}

			/** Checks whether optional parameter REMOTEPATH has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasRemotePath() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::REMOTEPATH::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::REMOTEPATH::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets REMOTEPATH parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::REMOTEPATH::ConstReferenceType getRemotePath() const
			{
				return mrParameterList[Parameters::REMOTEPATH::Index].convertTo<Parameters::REMOTEPATH::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct WHITEBOARD_TEST_ECHO
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 270, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 270;

	struct GET
	{
		typedef ListOfBytes Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			struct DATA
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef ListOfBytes Type;
				typedef const Type& ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/Test/Echo */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets DATA parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::DATA::ConstReferenceType getData() const
			{
				return mrParameterList[Parameters::DATA::Index].convertTo<Parameters::DATA::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct WHITEBOARD_TEST_NULL
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 271, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 271;

	struct PUT
	{
		struct Parameters
		{
			struct VALUE
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef ListOfBytes Type;
				typedef const Type& ConstReferenceType;
			};

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/Test/Null */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets VALUE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::VALUE::ConstReferenceType getValue() const
			{
				return mrParameterList[Parameters::VALUE::Index].convertTo<Parameters::VALUE::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};
	};
};

struct WHITEBOARD_TEST_PING
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 272, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 272;

	struct GET
	{
		typedef int64 Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};
	};
};

struct WHITEBOARD_TEST_ZERO
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_PRIMARYSERVICES;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 273, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 273;

	struct GET
	{
		typedef ListOfBytes Response_HTTP_CODE_OK_Type;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};
	};
};


} // namespace LOCAL

} // namespace WB_RES
