#pragma once
/***********************************************************************
* THIS FILE HAS BEEN GENERATED BY WBRES TOOL. DO NOT TRY TO CHANGE IT. *
***********************************************************************/
// Copyright (c) Suunto Oy 2014 - 2017. All rights reserved.

#include "whiteboard/Identifiers.h"
#include "whiteboard/ParameterList.h"
#include "whiteboard/Result.h"
#include "whiteboard/ResourceClient.h"

#include "whiteboard/builtinTypes/Array.h"
#include "whiteboard/builtinTypes/ByteStream.h"
#include "whiteboard/builtinTypes/Date.h"
#include "whiteboard/builtinTypes/DateTime.h"
#include "whiteboard/builtinTypes/Optional.h"
#include "whiteboard/builtinTypes/Structures.h"
#include "whiteboard/builtinTypes/Time.h"
#include "whiteboard/builtinTypes/Timestamp.h"
#include "whiteboard/builtinTypes/TypedEnum.h"
#include "whiteboard/builtinTypes/Vector2D.h"
#include "whiteboard/builtinTypes/Vector3D.h"
#include "whiteboard/builtinTypes/WrapperFor32BitPointer.h"

#define WB_RESOURCE_VALUE(whiteboardId, localResourceId, executionContextId) \
    static_cast<whiteboard::ResourceId::Value>( \
        (static_cast<uint32>(localResourceId) << 16) | \
        (static_cast<uint32>(whiteboardId) << 8) | \
        (static_cast<uint32>(executionContextId) << 4) | \
        (static_cast<uint32>(whiteboard::ID_INVALID_RESOURCE_INSTANCE)))

#define WB_CALLER_CONTEXT whiteboard::ID_INVALID_EXECUTION_CONTEXT


#define WB_EXEC_CTX_APPLICATION                  static_cast<whiteboard::ExecutionContextId>(0)

namespace WB_RES {

WB_STRUCT_PACK_BEGIN()

struct ThreadStateValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 257;

	enum Type
	{
		READY = 0U,
		RUNNING = 1U,
		BLOCKED = 2U,
		SUSPENDED = 3U,
		TERMINATED = 4U
	};
};
typedef whiteboard::TypedEnum<ThreadStateValues, ThreadStateValues::Type, uint8> ThreadState;

struct RouteStateValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 261;

	enum Type
	{
		ROUTE_STATE_NOT_USED = 0U,
		ROUTE_STATE_ADAPTER_DISABLED = 1U,
		ROUTE_STATE_NOT_CONNECTED = 2U,
		ROUTE_STATE_CONNECTING = 3U,
		ROUTE_STATE_HANDSHAKING = 4U,
		ROUTE_STATE_ESTABLISHED = 5U,
		ROUTE_STATE_DISCONNECTING = 6U,
		ROUTE_STATE_ERROR = 7U
	};
};
typedef whiteboard::TypedEnum<RouteStateValues, RouteStateValues::Type, uint8> RouteState;

struct RoutingTableNotificationTypeValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 262;

	enum Type
	{
		ROUTE_NOTIFICATION_NEW = 0U,
		ROUTE_NOTIFICATION_LOST = 1U,
		ROUTE_NOTIFICATION_ERROR = 2U
	};
};
typedef whiteboard::TypedEnum<RoutingTableNotificationTypeValues, RoutingTableNotificationTypeValues::Type, uint8> RoutingTableNotificationType;

struct ModuleCommandValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 264;

	enum Type
	{
		INITIALIZE = 0U,
		START = 1U,
		STOP = 2U,
		DEINITIALIZE = 3U
	};
};
typedef whiteboard::TypedEnum<ModuleCommandValues, ModuleCommandValues::Type, uint8> ModuleCommand;

struct ModuleStateValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 265;

	enum Type
	{
		UNINITIALIZED = 0U,
		INITIALIZED = 1U,
		STARTED = 2U,
		STOPPED = 3U,
		INITFAILED = 4U,
		FAILURE = 5U
	};
};
typedef whiteboard::TypedEnum<ModuleStateValues, ModuleStateValues::Type, uint8> ModuleState;

struct ThreadPriorityValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 269;

	enum Type
	{
		NOT_AVAILABLE = 0U,
		LOW = 1U,
		NORMAL = 2U,
		HIGH = 3U
	};
};
typedef whiteboard::TypedEnum<ThreadPriorityValues, ThreadPriorityValues::Type, uint8> ThreadPriority;

struct OperationTypeValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 36;

	enum Type
	{
		GET = 0U,
		PUT = 1U,
		POST = 2U,
		DELETE = 3U,
		SUBSCRIBE = 4U,
		UNSUBSCRIBE = 5U
	};
};
typedef whiteboard::TypedEnum<OperationTypeValues, OperationTypeValues::Type, uint8> OperationType;

struct DataTypeTypeValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 40;

	enum Type
	{
		SCALAR = 0U,
		NAMED = 1U,
		ARRAY = 2U,
		STRUCTURE = 3U,
		ENUMERATION = 4U
	};
};
typedef whiteboard::TypedEnum<DataTypeTypeValues, DataTypeTypeValues::Type, uint8> DataTypeType;

struct ScalarTypeValues
{
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 270;

	enum Type
	{
		NONE = 0U,
		BOOL = 1U,
		INT8 = 2U,
		UINT8 = 3U,
		INT16 = 4U,
		UINT16 = 5U,
		INT32 = 6U,
		UINT32 = 7U,
		INT64 = 8U,
		UINT64 = 9U,
		FLOAT = 10U,
		DOUBLE = 11U,
		STRING = 12U,
		LIST_OF_BYTES = 13U,
		BYTE_STREAM = 14U,
		LIST_OF_STRINGS = 15U,
		STRUCTURE = 16U
	};
};
typedef whiteboard::TypedEnum<ScalarTypeValues, ScalarTypeValues::Type, uint8> ScalarType;

struct WB_STRUCT_PACKED ListOfBytes;
struct WB_STRUCT_PACKED ListOfStrings;
struct WB_STRUCT_PACKED ExecutionContextMetadata;
struct WB_STRUCT_PACKED ResourceMetadata;
struct WB_STRUCT_PACKED OperationMetadata;
struct WB_STRUCT_PACKED ResponseMetadata;
struct WB_STRUCT_PACKED ParameterMetadata;
struct WB_STRUCT_PACKED StructurePropertyMetadata;
struct WB_STRUCT_PACKED EnumerationItemMetadata;
struct WB_STRUCT_PACKED DataTypeMetadata;
struct WB_STRUCT_PACKED SecurityTagMetadata;
struct WB_STRUCT_PACKED StringMetadata;
struct WB_STRUCT_PACKED WbInfo;
struct WB_STRUCT_PACKED ThreadInfo;
struct WB_STRUCT_PACKED ThreadInfoList;
struct WB_STRUCT_PACKED RoutingTable;
struct WB_STRUCT_PACKED CompactWbVersion;
struct WB_STRUCT_PACKED LaunchableModule;
struct WB_STRUCT_PACKED LaunchableList;

typedef int8 ThreadPriorityLevel;
typedef uint16 StringId;
typedef uint8 SecurityTagId;
typedef uint8 ResourceInstanceId;
typedef uint16 LocalOperationId;
typedef uint16 LocalResponseId;
typedef uint16 LocalParameterId;
typedef uint16 ScalarUnit;

struct WB_STRUCT_PACKED ListOfBytes
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 32;
	static const whiteboard::StructureValueSerializer<ListOfBytes> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<ListOfBytes> cleaner;)

	WB_ALIGN(4) whiteboard::Array< uint8 > items;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(items);
	}
};

struct WB_STRUCT_PACKED ListOfStrings
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 33;
	static const whiteboard::StructureValueSerializer<ListOfStrings> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<ListOfStrings> cleaner;)

	WB_ALIGN(4) whiteboard::Array< whiteboard::WrapperFor32BitPointer<const char> > items;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(items);
	}
};

struct WB_STRUCT_PACKED ExecutionContextMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 34;
	static const whiteboard::StructureValueSerializer<ExecutionContextMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<ExecutionContextMetadata> cleaner;)

	WB_ALIGN(1) whiteboard::ExecutionContextId id;
	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> name;
	WB_ALIGN(1) uint8 numberOfDpcs;
	WB_ALIGN(1) uint8 numberOfRequests;
	WB_ALIGN(1) uint8 numberOfResponses;
	WB_ALIGN(2) uint16 stackSize;
	WB_ALIGN(1) ThreadPriority priority;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(name)
			.visit(numberOfDpcs)
			.visit(numberOfRequests)
			.visit(numberOfResponses)
			.visit(stackSize)
			.visit(priority);
	}
};

struct WB_STRUCT_PACKED ResourceMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 35;
	static const whiteboard::StructureValueSerializer<ResourceMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<ResourceMetadata> cleaner;)

	WB_ALIGN(2) whiteboard::LocalResourceId id;
	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> name;
	WB_ALIGN(1) whiteboard::ExecutionContextId executionContextId;
	WB_ALIGN(4) whiteboard::Array< LocalOperationId > operationIdList;
	WB_ALIGN(2) LocalParameterId pathParameterId;
	WB_ALIGN(2) whiteboard::LocalResourceId parentId;
	WB_ALIGN(2) whiteboard::LocalResourceId nextSiblingId;
	WB_ALIGN(2) whiteboard::LocalResourceId firstChildId;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(name)
			.visit(executionContextId)
			.visit(operationIdList)
			.visit(pathParameterId)
			.visit(parentId)
			.visit(nextSiblingId)
			.visit(firstChildId);
	}
};

struct WB_STRUCT_PACKED OperationMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 37;
	static const whiteboard::StructureValueSerializer<OperationMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<OperationMetadata> cleaner;)

	WB_ALIGN(2) LocalOperationId id;
	WB_ALIGN(1) OperationType type;
	WB_ALIGN(4) uint32 securityMask;
	WB_ALIGN(4) whiteboard::Array< LocalParameterId > parameterIdList;
	WB_ALIGN(4) whiteboard::Array< LocalResponseId > responseIdList;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(type)
			.visit(securityMask)
			.visit(parameterIdList)
			.visit(responseIdList);
	}
};

struct WB_STRUCT_PACKED ResponseMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 38;
	static const whiteboard::StructureValueSerializer<ResponseMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<ResponseMetadata> cleaner;)

	WB_ALIGN(2) LocalResponseId id;
	WB_ALIGN(2) uint16 code;
	WB_ALIGN(2) whiteboard::LocalDataTypeId dataTypeId;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(code)
			.visit(dataTypeId);
	}
};

struct WB_STRUCT_PACKED ParameterMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 39;
	static const whiteboard::StructureValueSerializer<ParameterMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<ParameterMetadata> cleaner;)

	WB_ALIGN(2) LocalParameterId id;
	WB_ALIGN(2) StringId nameId;
	WB_ALIGN(1) bool required;
	WB_ALIGN(2) whiteboard::LocalDataTypeId dataTypeId;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(nameId)
			.visit(required)
			.visit(dataTypeId);
	}
};

struct WB_STRUCT_PACKED StructurePropertyMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 41;
	static const whiteboard::StructureValueSerializer<StructurePropertyMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<StructurePropertyMetadata> cleaner;)

	WB_ALIGN(2) StringId nameId;
	WB_ALIGN(2) whiteboard::LocalDataTypeId dataTypeId;
	WB_ALIGN(1) bool required;
	WB_ALIGN(1) bool inlineStorage;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(nameId)
			.visit(dataTypeId)
			.visit(required)
			.visit(inlineStorage);
	}
};

struct WB_STRUCT_PACKED EnumerationItemMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 42;
	static const whiteboard::StructureValueSerializer<EnumerationItemMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<EnumerationItemMetadata> cleaner;)

	WB_ALIGN(2) StringId nameId;
	WB_ALIGN(2) int16 value;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(nameId)
			.visit(value);
	}
};

struct WB_STRUCT_PACKED DataTypeMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 43;
	static const whiteboard::StructureValueSerializer<DataTypeMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<DataTypeMetadata> cleaner;)

	WB_ALIGN(2) whiteboard::LocalDataTypeId id;
	WB_ALIGN(1) DataTypeType type;
	WB_ALIGN(1) whiteboard::Optional< ScalarType > scalarType;
	WB_ALIGN(2) whiteboard::Optional< ScalarUnit > scalarUnit;
	WB_ALIGN(2) whiteboard::Optional< StringId > nameId;
	WB_ALIGN(2) whiteboard::Optional< whiteboard::LocalDataTypeId > baseTypeId;
	WB_ALIGN(4) whiteboard::Optional< whiteboard::Array< StructurePropertyMetadata > > properties;
	WB_ALIGN(4) whiteboard::Optional< whiteboard::Array< EnumerationItemMetadata > > items;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(type)
			.visit(scalarType)
			.visit(scalarUnit)
			.visit(nameId)
			.visit(baseTypeId)
			.visit(properties)
			.visit(items);
	}
};

struct WB_STRUCT_PACKED SecurityTagMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 44;
	static const whiteboard::StructureValueSerializer<SecurityTagMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<SecurityTagMetadata> cleaner;)

	WB_ALIGN(1) SecurityTagId id;
	WB_ALIGN(2) StringId nameId;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(nameId);
	}
};

struct WB_STRUCT_PACKED StringMetadata
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 45;
	static const whiteboard::StructureValueSerializer<StringMetadata> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<StringMetadata> cleaner;)

	WB_ALIGN(2) uint16 id;
	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> name;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(id)
			.visit(name);
	}
};

struct WB_STRUCT_PACKED WbInfo
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 256;
	static const whiteboard::StructureValueSerializer<WbInfo> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<WbInfo> cleaner;)

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> version;
	WB_ALIGN(1) uint8 commVersion;
	WB_ALIGN(1) uint8 minCommVersion;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(version)
			.visit(commVersion)
			.visit(minCommVersion);
	}
};

struct WB_STRUCT_PACKED ThreadInfo
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 258;
	static const whiteboard::StructureValueSerializer<ThreadInfo> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<ThreadInfo> cleaner;)

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> name;
	WB_ALIGN(1) ThreadState state;
	WB_ALIGN(1) ThreadPriorityLevel basePriority;
	WB_ALIGN(1) ThreadPriorityLevel currentPriority;
	WB_ALIGN(1) uint8 runTimePercentage;
	WB_ALIGN(4) uint32 runTimeTicks;
	WB_ALIGN(4) uint32 contextSwitches;
	WB_ALIGN(4) uint32 freeStack;
	WB_ALIGN(4) uint32 programCounter;
	WB_ALIGN(4) uint32 returnAddress;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(name)
			.visit(state)
			.visit(basePriority)
			.visit(currentPriority)
			.visit(runTimePercentage)
			.visit(runTimeTicks)
			.visit(contextSwitches)
			.visit(freeStack)
			.visit(programCounter)
			.visit(returnAddress);
	}
};

struct WB_STRUCT_PACKED ThreadInfoList
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 259;
	static const whiteboard::StructureValueSerializer<ThreadInfoList> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<ThreadInfoList> cleaner;)

	WB_ALIGN(4) whiteboard::Array< ThreadInfo > threads;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(threads);
	}
};

struct WB_STRUCT_PACKED RoutingTable
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 260;
	static const whiteboard::StructureValueSerializer<RoutingTable> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<RoutingTable> cleaner;)

	WB_ALIGN(1) uint8 version;
	WB_ALIGN(4) ListOfStrings serialNumbers;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(version)
			.visit(serialNumbers);
	}
};

struct WB_STRUCT_PACKED CompactWbVersion
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 263;
	static const whiteboard::StructureValueSerializer<CompactWbVersion> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<CompactWbVersion> cleaner;)

	WB_ALIGN(1) uint8 majorVersion;
	WB_ALIGN(1) uint8 minorVersion;
	WB_ALIGN(1) uint8 patchVersion;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(majorVersion)
			.visit(minorVersion)
			.visit(patchVersion);
	}
};

struct WB_STRUCT_PACKED LaunchableModule
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 266;
	static const whiteboard::StructureValueSerializer<LaunchableModule> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<LaunchableModule> cleaner;)

	WB_ALIGN(4) whiteboard::WrapperFor32BitPointer<const char> name;
	WB_ALIGN(1) ModuleState state;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(name)
			.visit(state);
	}
};

struct WB_STRUCT_PACKED LaunchableList
{
	// Structure type identification and serialization
	typedef int Structure;
	static const whiteboard::LocalDataTypeId DATA_TYPE_ID = 267;
	static const whiteboard::StructureValueSerializer<LaunchableList> serializer;
	WB_WHEN_STRUCTURE_CLEANING_NEEDED(static const whiteboard::StructureValueCleaner<LaunchableList> cleaner;)

	WB_ALIGN(4) whiteboard::Array< LaunchableModule > modules;

	inline void visit(whiteboard::IStructureVisitor& rVisitor)
	{
		rVisitor
			.visit(modules);
	}
};

WB_STRUCT_PACK_END()

namespace LOCAL
{

struct ROOT;

struct META;

struct META_DATATYPE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 11, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 11;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const DataTypeMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct TYPEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef TYPEID Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/DataType */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets TYPEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::TYPEID::ConstReferenceType getTypeId() const
			{
				return mrParameterList[Parameters::TYPEID::Index].convertTo<Parameters::TYPEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::TYPEID::ConstReferenceType)
		{
		}
	};
};

struct META_EXECUTIONCONTEXT
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 1, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 1;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const ExecutionContextMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct EXECUTIONCONTEXTID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			typedef EXECUTIONCONTEXTID Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/ExecutionContext */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets EXECUTIONCONTEXTID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::EXECUTIONCONTEXTID::ConstReferenceType getExecutionContextId() const
			{
				return mrParameterList[Parameters::EXECUTIONCONTEXTID::Index].convertTo<Parameters::EXECUTIONCONTEXTID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::EXECUTIONCONTEXTID::ConstReferenceType)
		{
		}
	};
};

struct META_HASH
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 14, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 14;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const char*, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct META_METADATASTREAM
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 13, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 13;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::ByteStream&, whiteboard::HTTP_CODE_CONTINUE> HTTP_CODE_CONTINUE;
		typedef whiteboard::StronglyTypedResult<const whiteboard::ByteStream&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_LOCKED> HTTP_CODE_LOCKED;

		struct Parameters
		{
			struct ORIGINALREQUESTID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef ORIGINALREQUESTID Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/MetadataStream */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Checks whether optional parameter ORIGINALREQUESTID has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasOriginalRequestId() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::ORIGINALREQUESTID::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::ORIGINALREQUESTID::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets ORIGINALREQUESTID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::ORIGINALREQUESTID::ConstReferenceType getOriginalRequestId() const
			{
				return mrParameterList[Parameters::ORIGINALREQUESTID::Index].convertTo<Parameters::ORIGINALREQUESTID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<Parameters::ORIGINALREQUESTID::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};
};

struct META_OPERATION
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 6, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 6;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const OperationMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct OPERATIONID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef OPERATIONID Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Operation */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets OPERATIONID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::OPERATIONID::ConstReferenceType getOperationId() const
			{
				return mrParameterList[Parameters::OPERATIONID::Index].convertTo<Parameters::OPERATIONID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::OPERATIONID::ConstReferenceType)
		{
		}
	};
};

struct META_OPERATION_PARAMETER
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 7, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 7;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const ParameterMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct OPERATIONID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef OPERATIONID Parameter1;

			struct PARAMETERINDEX
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			typedef PARAMETERINDEX Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Operation/Parameter */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets OPERATIONID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::OPERATIONID::ConstReferenceType getOperationId() const
			{
				return mrParameterList[Parameters::OPERATIONID::Index].convertTo<Parameters::OPERATIONID::ConstReferenceType>();
			}

			/** Gets PARAMETERINDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::PARAMETERINDEX::ConstReferenceType getParameterIndex() const
			{
				return mrParameterList[Parameters::PARAMETERINDEX::Index].convertTo<Parameters::PARAMETERINDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::OPERATIONID::ConstReferenceType,
			Parameters::PARAMETERINDEX::ConstReferenceType)
		{
		}
	};
};

struct META_PARAMETER
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 8, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 8;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const ParameterMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct PARAMETERID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef PARAMETERID Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Parameter */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets PARAMETERID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::PARAMETERID::ConstReferenceType getParameterId() const
			{
				return mrParameterList[Parameters::PARAMETERID::Index].convertTo<Parameters::PARAMETERID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::PARAMETERID::ConstReferenceType)
		{
		}
	};
};

struct META_RESOURCE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 3, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 3;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const ResourceMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Resource */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::RESOURCEID::ConstReferenceType)
		{
		}
	};
};

struct META_RESOURCE_OPERATION
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 4, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 4;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const OperationMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter1;

			struct OPERATIONTYPE
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef OperationType Type;
				typedef Type ConstReferenceType;
			};

			typedef OPERATIONTYPE Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Resource/Operation */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

			/** Gets OPERATIONTYPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::OPERATIONTYPE::ConstReferenceType getOperationType() const
			{
				return mrParameterList[Parameters::OPERATIONTYPE::Index].convertTo<Parameters::OPERATIONTYPE::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::RESOURCEID::ConstReferenceType,
			Parameters::OPERATIONTYPE::ConstReferenceType)
		{
		}
	};
};

struct META_RESOURCE_RESPONSE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 5, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 5;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const ResponseMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct RESOURCEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEID Parameter1;

			struct OPERATIONTYPE
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef OperationType Type;
				typedef Type ConstReferenceType;
			};

			typedef OPERATIONTYPE Parameter2;

			struct RESPONSEINDEX
			{
				static const whiteboard::ParameterIndex Index = 2;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESPONSEINDEX Parameter3;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 3;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Resource/Response */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESOURCEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEID::ConstReferenceType getResourceId() const
			{
				return mrParameterList[Parameters::RESOURCEID::Index].convertTo<Parameters::RESOURCEID::ConstReferenceType>();
			}

			/** Gets OPERATIONTYPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::OPERATIONTYPE::ConstReferenceType getOperationType() const
			{
				return mrParameterList[Parameters::OPERATIONTYPE::Index].convertTo<Parameters::OPERATIONTYPE::ConstReferenceType>();
			}

			/** Gets RESPONSEINDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESPONSEINDEX::ConstReferenceType getResponseIndex() const
			{
				return mrParameterList[Parameters::RESPONSEINDEX::Index].convertTo<Parameters::RESPONSEINDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::RESOURCEID::ConstReferenceType,
			Parameters::OPERATIONTYPE::ConstReferenceType,
			Parameters::RESPONSEINDEX::ConstReferenceType)
		{
		}
	};
};

struct META_RESOURCEID
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 2, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 2;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<uint16, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct RESOURCEURI
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef const char* Type;
				typedef Type ConstReferenceType;
			};

			typedef RESOURCEURI Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/ResourceId */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESOURCEURI parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESOURCEURI::ConstReferenceType getResourceUri() const
			{
				return mrParameterList[Parameters::RESOURCEURI::Index].convertTo<Parameters::RESOURCEURI::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::RESOURCEURI::ConstReferenceType)
		{
		}
	};
};

struct META_RESPONSE
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 9, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 9;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const ResponseMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct RESPONSEID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef RESPONSEID Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/Response */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets RESPONSEID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::RESPONSEID::ConstReferenceType getResponseId() const
			{
				return mrParameterList[Parameters::RESPONSEID::Index].convertTo<Parameters::RESPONSEID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::RESPONSEID::ConstReferenceType)
		{
		}
	};
};

struct META_SECURITYTAG
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 10, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 10;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const SecurityTagMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct SECURITYTAGID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			typedef SECURITYTAGID Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/SecurityTag */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets SECURITYTAGID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::SECURITYTAGID::ConstReferenceType getSecurityTagId() const
			{
				return mrParameterList[Parameters::SECURITYTAGID::Index].convertTo<Parameters::SECURITYTAGID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::SECURITYTAGID::ConstReferenceType)
		{
		}
	};
};

struct META_STRING
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 12, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 12;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const StringMetadata&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;

		struct Parameters
		{
			struct STRINGID
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef STRINGID Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Meta/String */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets STRINGID parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::STRINGID::ConstReferenceType getStringId() const
			{
				return mrParameterList[Parameters::STRINGID::Index].convertTo<Parameters::STRINGID::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::STRINGID::ConstReferenceType)
		{
		}
	};
};

struct NET
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 256, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 256;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const RoutingTable&, whiteboard::HTTP_CODE_CONTINUE> HTTP_CODE_CONTINUE;
		typedef whiteboard::StronglyTypedResult<const RoutingTable&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			struct CONTINUATIONINDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint32 Type;
				typedef Type ConstReferenceType;
			};

			typedef CONTINUATIONINDEX Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Net */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Checks whether optional parameter CONTINUATIONINDEX has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasContinuationIndex() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::CONTINUATIONINDEX::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::CONTINUATIONINDEX::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets CONTINUATIONINDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::CONTINUATIONINDEX::ConstReferenceType getContinuationIndex() const
			{
				return mrParameterList[Parameters::CONTINUATIONINDEX::Index].convertTo<Parameters::CONTINUATIONINDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<Parameters::CONTINUATIONINDEX::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};

	struct SUBSCRIBE
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};

	struct EVENT
	{
		typedef const char* NotificationType;
		typedef NotificationType ConstReferenceNotificationType;

		struct Parameters
		{
			struct NOTIFICATIONTYPE
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef RoutingTableNotificationType Type;
				typedef Type ConstReferenceType;
			};

			typedef NOTIFICATIONTYPE Parameter1;

			struct REMOTEWHITEBOARDIDINLOCALSCOPE
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef uint8 Type;
				typedef Type ConstReferenceType;
			};

			typedef REMOTEWHITEBOARDIDINLOCALSCOPE Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Net */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets NOTIFICATIONTYPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::NOTIFICATIONTYPE::ConstReferenceType getNotificationType() const
			{
				return mrParameterList[Parameters::NOTIFICATIONTYPE::Index].convertTo<Parameters::NOTIFICATIONTYPE::ConstReferenceType>();
			}

			/** Gets REMOTEWHITEBOARDIDINLOCALSCOPE parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::ConstReferenceType getRemoteWhiteboardIdInLocalScope() const
			{
				return mrParameterList[Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::Index].convertTo<Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<ConstReferenceNotificationType>&,
			Parameters::NOTIFICATIONTYPE::ConstReferenceType,
			Parameters::REMOTEWHITEBOARDIDINLOCALSCOPE::ConstReferenceType)
		{
		}
	};

	struct UNSUBSCRIBE
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct WHITEBOARD;

struct WHITEBOARD_INFO
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 257, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 257;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const WbInfo&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct WHITEBOARD_METRICS;

struct WHITEBOARD_METRICS_THREADS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 258, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 258;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const ThreadInfoList&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct WHITEBOARD_METRICS_THREADS_COUNT
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 259, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 259;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<uint8, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;

		struct Parameters
		{
			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 0;
		};

		/** Compile time type checking */
		inline static void typeCheck()
		{
		}
	};
};

struct WHITEBOARD_METRICS_THREADS_INDEX;

struct WHITEBOARD_METRICS_THREADS_INDEX_NAME
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 260, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 260;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const char*, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_RANGE_NOT_SATISFIABLE> HTTP_CODE_RANGE_NOT_SATISFIABLE;

		struct Parameters
		{
			struct INDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef int32 Type;
				typedef Type ConstReferenceType;
			};

			typedef INDEX Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/Metrics/Threads/{index}/Name */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets INDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::INDEX::ConstReferenceType getIndex() const
			{
				return mrParameterList[Parameters::INDEX::Index].convertTo<Parameters::INDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::INDEX::ConstReferenceType)
		{
		}
	};
};

struct WHITEBOARD_METRICS_THREADS_INDEX_PROGRAMCOUNTER
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 261, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 261;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<uint32, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_RANGE_NOT_SATISFIABLE> HTTP_CODE_RANGE_NOT_SATISFIABLE;

		struct Parameters
		{
			struct INDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef int32 Type;
				typedef Type ConstReferenceType;
			};

			typedef INDEX Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/Metrics/Threads/{index}/ProgramCounter */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets INDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::INDEX::ConstReferenceType getIndex() const
			{
				return mrParameterList[Parameters::INDEX::Index].convertTo<Parameters::INDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::INDEX::ConstReferenceType)
		{
		}
	};
};

struct WHITEBOARD_METRICS_THREADS_INDEX_RETURNADDRESS
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 262, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 262;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<uint32, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_RANGE_NOT_SATISFIABLE> HTTP_CODE_RANGE_NOT_SATISFIABLE;

		struct Parameters
		{
			struct INDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef int32 Type;
				typedef Type ConstReferenceType;
			};

			typedef INDEX Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/Metrics/Threads/{index}/ReturnAddress */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets INDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::INDEX::ConstReferenceType getIndex() const
			{
				return mrParameterList[Parameters::INDEX::Index].convertTo<Parameters::INDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::INDEX::ConstReferenceType)
		{
		}
	};
};

struct WHITEBOARD_SYSTEM;

struct WHITEBOARD_SYSTEM_LAUNCHER
{
	static const whiteboard::ExecutionContextId EXECUTION_CONTEXT = WB_EXEC_CTX_APPLICATION;
	static const whiteboard::ResourceId::Value ID = WB_RESOURCE_VALUE(0, 263, EXECUTION_CONTEXT);
	static const whiteboard::LocalResourceId LID = 263;

	struct GET
	{
		typedef whiteboard::StronglyTypedResult<const LaunchableList&, whiteboard::HTTP_CODE_CONTINUE> HTTP_CODE_CONTINUE;
		typedef whiteboard::StronglyTypedResult<const LaunchableList&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_RANGE_NOT_SATISFIABLE> HTTP_CODE_RANGE_NOT_SATISFIABLE;

		struct Parameters
		{
			struct MODULESTARTINDEX
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef uint16 Type;
				typedef Type ConstReferenceType;
			};

			typedef MODULESTARTINDEX Parameter1;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 1;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/System/Launcher */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Checks whether optional parameter MODULESTARTINDEX has a value
			*
			* @return A value indicating whether the parameter has a value
			*/
			inline bool hasModuleStartIndex() const
			{
				if (mrParameterList.getNumberOfParameters() <= Parameters::MODULESTARTINDEX::Index)
				{
					return false;
				}

				return mrParameterList[Parameters::MODULESTARTINDEX::Index].getType() != whiteboard::WB_TYPE_NONE;
			}

			/** Gets MODULESTARTINDEX parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::MODULESTARTINDEX::ConstReferenceType getModuleStartIndex() const
			{
				return mrParameterList[Parameters::MODULESTARTINDEX::Index].convertTo<Parameters::MODULESTARTINDEX::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			const whiteboard::Api::OptionalParameter<Parameters::MODULESTARTINDEX::ConstReferenceType>& = whiteboard::NoType::NoValue)
		{
		}
	};

	struct PUT
	{
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_OK> HTTP_CODE_OK;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_BAD_REQUEST> HTTP_CODE_BAD_REQUEST;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_NOT_FOUND> HTTP_CODE_NOT_FOUND;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_BAD_METHOD> HTTP_CODE_BAD_METHOD;
		typedef whiteboard::StronglyTypedResult<const whiteboard::NoType&, whiteboard::HTTP_CODE_INTERNAL_SERVER_ERROR> HTTP_CODE_INTERNAL_SERVER_ERROR;

		struct Parameters
		{
			struct NAME
			{
				static const whiteboard::ParameterIndex Index = 0;

				typedef const char* Type;
				typedef Type ConstReferenceType;
			};

			typedef NAME Parameter1;

			struct COMMAND
			{
				static const whiteboard::ParameterIndex Index = 1;

				typedef ModuleCommand Type;
				typedef Type ConstReferenceType;
			};

			typedef COMMAND Parameter2;

			static const whiteboard::ParameterIndex NUMBER_OF_PARAMETERS = 2;
		};

		/** Reference wrapper for strongly typed parameter list for /Whiteboard/System/Launcher */
		class ParameterListRef
		{
		private:
			/** Prevent use of default constructor */
			ParameterListRef() DELETED;

			/** Prevent use of copy constructor */
			ParameterListRef(const ParameterListRef&) DELETED;

			/** Prevent use of assignment operator */
			const ParameterListRef& operator=(const ParameterListRef&) DELETED;

		public:
			/** Constructor that initializes this class from existing parameter list
			*
			* @param rParameterList Reference to parameter list that contains untyped parameters
			*/
			inline ParameterListRef(const whiteboard::ParameterList& rParameterList)
				: mrParameterList(rParameterList)
			{
			}

			/** Gets NAME parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::NAME::ConstReferenceType getName() const
			{
				return mrParameterList[Parameters::NAME::Index].convertTo<Parameters::NAME::ConstReferenceType>();
			}

			/** Gets COMMAND parameter value
			*
			* @return Current parameter value
			*/
			inline Parameters::COMMAND::ConstReferenceType getCommand() const
			{
				return mrParameterList[Parameters::COMMAND::Index].convertTo<Parameters::COMMAND::ConstReferenceType>();
			}

		private:
			/** Reference to actual parameter list */
			const whiteboard::ParameterList& mrParameterList;
		};

		/** Compile time type checking */
		inline static void typeCheck(
			Parameters::NAME::ConstReferenceType,
			Parameters::COMMAND::ConstReferenceType)
		{
		}
	};
};


} // namespace LOCAL

} // namespace WB_RES
