#pragma once
/******************************************************************************
Copyright (c) Suunto Oy 2014.
All rights reserved.
******************************************************************************/
#include "whiteboard/Functor.h"
#include "whiteboard/Identifiers.h"
#include "whiteboard/Request.h"
#include "whiteboard/Result.h"
#include "quantity/quantity/quantity.h"

namespace whiteboard
{

// Forward declarations
class IExecutionContext;
class Value;
class ParameterList;
struct MetadataMap;

namespace metadata
{

// TODO: Use WB structure packing

/** Reference to a security tag. */
typedef uint8 SecurityTagId;

/** Invalid security tag reference */
static const SecurityTagId INVALID_SECURITY_TAG = 0xff;

/** Reference to a operation list. */
typedef uint16 OperationListId;

/** Invalid operation list reference */
static const OperationListId INVALID_OPERATION_LIST = 0xffff;

/** Reference to a operation */
typedef uint16 OperationId;

/** Invalid operation reference */
static const OperationId INVALID_OPERATION = 0xffff;

/** Reference to a parameter list */
typedef uint16 ParameterListId;

/** Invalid parameter list reference */
static const ParameterListId INVALID_PARAMETER_LIST = 0xffff;

/** Reference to a parameter */
typedef uint16 ParameterId;

/** Invalid parameter reference */
static const ParameterId INVALID_PARAMETER = 0xffff;

/** Reference to a response list */
typedef uint16 ResponseListId;

/** Invalid response list reference */
static const ResponseListId INVALID_RESPONSE_LIST = 0xffff;

/** Reference to a response */
typedef uint16 ResponseId;

/** Invalid response reference */
static const ResponseId INVALID_RESPONSE = 0xffff;

/** Reference to a data type */
typedef uint16 DataTypeId;

/** Invalid data type reference */
static const DataTypeId INVALID_DATATYPE = 0xffff;

/** Reference to a property list type */
typedef uint16 PropertyListId;

/** Invalid proeprty list reference */
static const PropertyListId INVALID_PROPERTY_LIST = 0xffff;

/** Reference to a property type */
typedef uint16 PropertyId;

/** Invalid property reference */
static const PropertyId INVALID_PROPERTY = 0xffff;

/** Reference to a enumeration item list type */
typedef uint16 EnumerationItemListId;

/** Invalid proeprty list reference */
static const EnumerationItemListId INVALID_ENUMERATION_ITEM_LIST = 0xffff;

/** Reference to a string */
typedef uint16 StringId;

/** Invalid string reference */
static const StringId INVALID_STRING = 0xffff;

/** ID of the API that distincts resources and data types
 * that are generated by different WBRES builds.
 */
typedef uint8 ApiId;

/** Maximum number of APIs */
static const size_t MAX_NUMBER_APIS = 256;

/** Number of bits to shift IDs to get API ID */
static const size_t API_ID_SHIFT = 8;

/** Maximum number of resources per API */
static const size_t MAX_NUMBER_OF_RESOURCES_PER_API = 1 << API_ID_SHIFT;

/** Maximum number of data types per API */
static const size_t MAX_NUMBER_OF_DATATYPES_PER_API = 1 << API_ID_SHIFT;

/** Maximum number of fixed ID data types */
static const size_t MAX_FIXED_ID_DATATYPES = 256;

/** Reference to a mount point */
typedef uint8 MountPointId;

/** Invalid mount point reference */
static const MountPointId INVALID_MOUNT_POINT = 0xff;

/** Bit mask of security tags */
typedef uint32 SecurityMask;

/** Response code that is used to indicate notifications */
static const Result NOTIFICATION = static_cast<Result>(0);

/** Structure that stores security tag related meta data */
struct SecurityTag
{
    /** Name of the security tag */
    StringId nameId;
};

/** Execution context priority */
enum ExecutionContextPriority
{
    EXEC_CTX_PRIORITY_NOT_AVAILABLE = 0,
    EXEC_CTX_PRIORITY_LOW,
    EXEC_CTX_PRIORITY_NORMAL,
    EXEC_CTX_PRIORITY_HIGH
};

/** Structure that stores execution context settings */
struct ExecutionContextSettings
{
    /** Maximum number of DPCs allocated in execution context */
    uint8 numberOfDpcs;
    /** Maximum number of request events allocated in execution context */
    uint8 numberOfRequests;
    /** Maximum number of response events allocated in execution context */
    uint8 numberOfResponses;

    /** A value indicating whether this execution context should be run
    * by a external thread */
    uint8 externalThread : 1;

    /** Execution context priority
    *
    * @see ExecutionContextPriority enumeration
    */
    uint8 priority : 3;

    /** Reserved */
    uint8 reserved : 4;

    /** Size of the execution context thread stack */
    uint16 stackSize;

    /** Security rights of the execution context */
    SecurityMask securityMask;
};

#define ALL_ACCESS UINT32_MAX
#define INIT_EXEC_CTX_SETTINGS(numberOfDpcs, numberOfRequests, numberOfResponses, externalThread, priority, stackSize, securityMask) \
    { numberOfDpcs, numberOfRequests, numberOfResponses, externalThread  ? 1 : 0, priority, 0, stackSize, securityMask }

/** Structure that stores execution context related meta data */
#if 0
struct ExecutionContext
{
    /** ID of execution context name */
    StringId nameId;

    /** Settings */
    ExecutionContextSettings settings;
};
#endif

/** Function prototype for filtering incoming update notifications before local message dispatching.
 * Note that this function can be called simultaneously from multiple threads */
typedef IFunctor4<bool, whiteboard::ClientId, whiteboard::ResourceId, const whiteboard::Value&, const whiteboard::ParameterList&>
    ExecutionContextNoticationFilter;

/** Option that guide how events should be processed */
struct EventProcessorOptions
{
    /** Constructor */
    inline EventProcessorOptions(uint32 _timeout, bool _doEventProcessing)
        : timeout(WB_MIN(_timeout, MAXIMUM_TIMEOUT)), doEventProcessing(_doEventProcessing ? 1 : 0)
    {
    }

    /** Maximum number of milliseconds to wait for new DPCs and events before calling eventStateProcess
        * again. Use DEFAULT_TIMEOUT to use system default.
        *
        * @note This value specifies maximum only when there is no events. No maximum can be given for how long
        *       single event is processed.
        */
    uint32 timeout : 31;

    /** A flag that indicates that events can be processed for the duration of given timeout.
        *
        * @note DPCs are always processed even if this flag is cleared
        */
    uint32 doEventProcessing : 1;

    /** Maximum timeout value */
    static const uint32 MAXIMUM_TIMEOUT = WB_MIN((1u << 31) - 1, WB_INFINITE) - 1;
};

/** Function prototype for worker functions that perform custom processing between
 *  Whiteboard events handling.
 *
 *  @tparam bool : eventsPending; Does the execition context has events pending
 */
typedef IFunctor1<EventProcessorOptions, bool> ExecutionContextStateProcessor;

/** Execution context information */
struct ExecutionContextInfo
{
    /** Name of the execution context */
    const char* const name;
    
    /** Execution context settings */
    const metadata::ExecutionContextSettings settings;

    /** Pointer to function that is used to filter update notifications before dispatching. */
    ExecutionContextNoticationFilter* pNotificationFilter;

    /** Pointer to function that that performs custom processing between
     *  Whiteboard events handling. */
    ExecutionContextStateProcessor* pStateProcessor;
};

#define INIT_EXEC_CTX_INFO(name, numberOfDpcs, numberOfRequests, numberOfResponses, externalThread, priority, stackSize, securityMask) \
    { name, { numberOfDpcs, numberOfRequests, numberOfResponses, externalThread  ? 1 : 0, priority, 0, stackSize, securityMask }, NULL, NULL }

/** Structure that stores scalar data type related meta data */
struct ScalarType
{
    /** Type of the scalar data type
    *
    * @see ValueType enumeration
    */
    uint8 type;

    /** Reserved for future use. Needed for alignment */
    uint8 reserved;

    /** Unit info (quantity and unit ID) of the scalar data type
    *
    * @see unit::Info struct
    */
    unit::Info unitInfo;
};

/** Structure that stores named data type related meta data */
struct NamedType
{
    /** ID of type name */
    StringId nameId;

    /** Actual type of the named data type */
    DataTypeId typeId;
};

/** Structure that stores array data type related meta data */
struct ArrayType
{
    /** Item type */
    DataTypeId itemTypeId;
};

/** Structure that stores structure data type related meta data */
struct StructureType
{
    /** ID of the structure's property list */
    PropertyListId propertyListId;
};

/** Structure that stores structure data type related meta data */
struct Property
{
    /** Name of the property */
    StringId nameId;

    /** Property type */
    DataTypeId typeId;

    /** A value indicating whether the property is required */
    bool required;

    /** A value indicating whether the property is stored inline in the structure
    or whether it is stored as reference to actual data */
    bool inlineStorage;
};

/** Structure that stores property list meta data */
struct PropertyList
{
    /** Property ID array. Terminated by INVALID_PROPERTY */
    PropertyId propertyIds[1];

    /** Counts number of property IDs in the list
    *
    * @return Size of the list
    */
    inline size_t count() const
    {
        size_t i = 0;
        while (propertyIds[i] != INVALID_PROPERTY)
        {
            ++i;
        }
        return i;
    }

    /** Converts given null terminated property array to property list
    *
    * @param pNullTerminatedPropertyArray Null terminated array of properties
    * @return Parameter list reference
    */
    static const PropertyList& toList(const PropertyId* pNullTerminatedPropertyArray)
    {
        return *reinterpret_cast<const PropertyList*>(pNullTerminatedPropertyArray);
    }
};

/** Value type of enumeration */
typedef int32 EnumerationValue;

/** Structure that stores enumeration item related meta data */
struct EnumerationItem
{
    /** Name of the enumeration item */
    StringId nameId;

    /** Value of the enumeration item */
    EnumerationValue value;
};

/** Structure that stores enumeration item list meta data */
struct EnumerationItemList
{
    /** Enumeration item array. Terminated by { metadata::INVALID_STRING, 0 } */
    EnumerationItem enumerationItems[1];

    /** Counts number of enumeration items in the list
    *
    * @return Size of the list
    */
    inline size_t count() const
    {
        size_t i = 0;
        while (enumerationItems[i].nameId != INVALID_STRING)
        {
            ++i;
        }
        return i;
    }

    /** Converts given null terminated enumeration item array to enumeration item list
    *
    * @param pNullTerminatedEnumerationItemArray Null terminated array of enumeration items
    * @return Parameter list reference
    */
    static const EnumerationItemList&
        toList(const EnumerationItem* pNullTerminatedEnumerationItemArray)
    {
        return *reinterpret_cast<const EnumerationItemList*>(pNullTerminatedEnumerationItemArray);
    }
};

/** Structure that stores enumeration data type related meta data */
struct EnumerationType
{
    /** Base type */
    DataTypeId baseTypeId;

    /** ID of the structure's enumeration item list */
    EnumerationItemListId enumerationItemListId;
};

/** Type of a data type */
typedef enum
{
    DATATYPE_SCALAR,
    DATATYPE_NAMED,
    DATATYPE_ARRAY,
    DATATYPE_STRUCTURE,
    DATATYPE_ENUMERATION
} DataTypeType;

/** Helper structure for calculating required data type meta data size */
struct DataTypeContainer
{
    /** Union of type data */
    union
    {
        /** Scalar type information */
        ScalarType scalar;

        /** Named type information */
        NamedType named;

        /** Array type information */
        ArrayType array;

        /** Structure type information */
        StructureType structure;

        /** Enumeration type information */
        EnumerationType enumeration;
    };
};

// Check alignments
WB_STATIC_VERIFY(WB_TYPE_ALIGNMENT(ScalarType) <= 2, AlignmentOfScalarTypeIsNotWhatExpected);
WB_STATIC_VERIFY(WB_TYPE_ALIGNMENT(NamedType) <= 2, AlignmentOfNamedTypeIsNotWhatExpected);
WB_STATIC_VERIFY(WB_TYPE_ALIGNMENT(ArrayType) <= 2, AlignmentOfArrayTypeIsNotWhatExpected);
WB_STATIC_VERIFY(WB_TYPE_ALIGNMENT(StructureType) <= 2, AlignmentOfStructureTypeIsNotWhatExpected);
WB_STATIC_VERIFY(WB_TYPE_ALIGNMENT(EnumerationType) <= 2, AlignmentOfEnumerationTypeIsNotWhatExpected);

/** Structure that stores type meta data */
struct DataType
{
    /** Type of the data type.
    *
    * @see DataTypeType enumeration
    */
    uint8 type;

    /** Data storage for different data types. uint16 ensures correct alignment
    * for the sub data types.
    */
    uint16 data[(sizeof(DataTypeContainer) + sizeof(uint16) - 1) / sizeof(uint16)];

    /** Gets scalar data type
    *
    * @return Reference to scalar data type
    */
    inline ScalarType& getScalarDataType()
    {
        WB_ASSERT(type == DATATYPE_SCALAR);
        return *reinterpret_cast<ScalarType*>(data);
    }

    /** Gets scalar data type
    *
    * @return Reference to scalar data type
    */
    inline const ScalarType& getScalarDataType() const
    {
        WB_ASSERT(type == DATATYPE_SCALAR);
        return *reinterpret_cast<const ScalarType*>(data);
    }

    /** Gets named data type
    *
    * @return Reference to named data type
    */
    inline NamedType& getNamedDataType()
    {
        WB_ASSERT(type == DATATYPE_NAMED);
        return *reinterpret_cast<NamedType*>(data);
    }

    /** Gets named data type
    *
    * @return Reference to named data type
    */
    inline const NamedType& getNamedDataType() const
    {
        WB_ASSERT(type == DATATYPE_NAMED);
        return *reinterpret_cast<const NamedType*>(data);
    }

    /** Gets array data type
    *
    * @return Reference to array data type
    */
    inline ArrayType& getArrayDataType()
    {
        WB_ASSERT(type == DATATYPE_ARRAY);
        return *reinterpret_cast<ArrayType*>(data);
    }

    /** Gets array data type
    *
    * @return Reference to array data type
    */
    inline const ArrayType& getArrayDataType() const
    {
        WB_ASSERT(type == DATATYPE_ARRAY);
        return *reinterpret_cast<const ArrayType*>(data);
    }

    /** Gets structure data type
    *
    * @return Reference to structure data type
    */
    inline StructureType& getStructureDataType()
    {
        WB_ASSERT(type == DATATYPE_STRUCTURE);
        return *reinterpret_cast<StructureType*>(data);
    }

    /** Gets structure data type
    *
    * @return Reference to structure data type
    */
    inline const StructureType& getStructureDataType() const
    {
        WB_ASSERT(type == DATATYPE_STRUCTURE);
        return *reinterpret_cast<const StructureType*>(data);
    }

    /** Gets enumeration data type
    *
    * @return Reference to enumeration data type
    */
    inline EnumerationType& getEnumerationDataType()
    {
        WB_ASSERT(type == DATATYPE_ENUMERATION);
        return *reinterpret_cast<EnumerationType*>(data);
    }

    /** Gets enumeration data type
    *
    * @return Reference to enumeration data type
    */
    inline const EnumerationType& getEnumerationDataType() const
    {
        WB_ASSERT(type == DATATYPE_ENUMERATION);
        return *reinterpret_cast<const EnumerationType*>(data);
    }
};

/** Structure that stores parameter meta data */
struct Parameter
{
    /** ID of the parameter name */
    StringId nameId;

    /** A value indicating whether the parameter is required */
    bool required;

    /** ID of the parameter type */
    DataTypeId dataTypeId;
};

/** Structure that stores parameter list meta data */
struct ParameterList
{
    /** Parameter ID array. Terminated by INVALID_PARAMETER */
    ParameterId parameterIds[1];

    /** Counts number of parameter IDs in the list
    *
    * @return Size of the list
    */
    inline size_t count() const
    {
        size_t i = 0;
        while (parameterIds[i] != INVALID_PARAMETER)
        {
            ++i;
        }
        return i;
    }

    /** Converts given null terminated parameter array to parameter list
    *
    * @param pNullTerminatedParameterArray Null terminated array of parameters
    * @return Parameter list reference
    */
    static const ParameterList& toList(const ParameterId* pNullTerminatedParameterArray)
    {
        return *reinterpret_cast<const ParameterList*>(pNullTerminatedParameterArray);
    }
};

/** Structure that stores response meta data */
struct Response
{
    /** Result code
    *
    * @see Result enumeration
    */
    uint16 code;

    /** ID of result type */
    DataTypeId dataTypeId;
};

/** Structure that stores response list meta data */
struct ResponseList
{
    /** Response ID array. Terminated by INVALID_RESPONSE */
    ResponseId responseIds[1];

    /** Counts number of response IDs in the list
    *
    * @return Size of the list
    */
    inline size_t count() const
    {
        size_t i = 0;
        while (responseIds[i] != INVALID_RESPONSE)
        {
            ++i;
        }
        return i;
    }

    /** Converts given null terminated response array to response list
    *
    * @param pNullTerminatedResponseArray Null terminated array of responses
    * @return Response list reference
    */
    static const ResponseList& toList(const ResponseId* pNullTerminatedResponseArray)
    {
        return *reinterpret_cast<const ResponseList*>(pNullTerminatedResponseArray);
    }
};

/** Structure that stores operation meta data */
struct Operation
{
    /** Type of the operation
    *
    * @see OperationType enumeration
    */
    uint8 operationType;

    /** Parameter list ID */
    ParameterListId parameterListId;

    /** Response list ID */
    ResponseListId responseListId;

    /** Required security mask */
    SecurityMask securityMask;
};

/** Structure that stores list of operations */
struct OperationList
{
    /** Operation IDs (GET, PUT, POST, DELETE, SUBSCRIBE, UNSUBSCRIBE) */
    OperationId operationIds[6];

    /** Gets operation id for specific request type
     *
     * @param type Request type
     * @return Operation ID of the request type
     */
    inline OperationId getOperationIdByType(RequestType type) const
    {
        WB_DEBUG_ASSERT(type < ELEMENTS(operationIds));
        return operationIds[type];
    }

    /** Converts given null terminated operation array to operation list
    *
    * @param pNullTerminatedOperationArray Null terminated array of operations
    * @return Operation list reference
    */
    static const OperationList& toList(const OperationId* pNullTerminatedOperationArray)
    {
        return *reinterpret_cast<const OperationList*>(pNullTerminatedOperationArray);
    }
};

/** Structure that stores path meta data */
struct Path
{
    /** Name of the resource */
    StringId nameId;

    /** A value indicating whether this is some other type than path (0 = path, 1 = other type) */
    uint8 isOtherType : 1;

    /** Execution context id */
    ExecutionContextId executionContextId : 4;

    /** Number of path variables */
    uint8 pathParameterCount : 3;

    /** Reserved for alignment */
    uint8 reserved;

    /** ID of the parent resource */
    LocalResourceId parentId;

    /** ID of next sibling in the resource tree */
    LocalResourceId nextSiblingId;

    /** ID of first child in the resource tree */
    LocalResourceId firstChildId;

    /** Operation */
    OperationListId operations;

    /** Path parameter */
    ParameterId pathParameter;
};

enum ResourceTreeNodeType
{
    NODE_TYPE_PATH = 0,         // isOtherType = 0, otherType = N/A
    NODE_TYPE_MOUNTPOINT = 2,   // isOtherType = 1, otherType = 0
    NODE_TYPE_CONSTSYMLINK = 3, // isOtherType = 1, otherType = 1
};

/** Structure that stores mount point information */
struct MountPoint
{
    /** Name of the resource */
    StringId nameId;

    /** A value indicating whether this is some other type than path (0 = path, 1 = other type) */
    uint8 isOtherType : 1;

    /** A value indicating the other type, see enum OtherNodeType (0 = mount point, 1 = symlink) */
    uint8 otherType : 1;

    /** Reserved for future use */
    uint8 reserved : 6;

    /** Reserved for alignment */
    uint8 reserved2;

    /** ID of the parent resource */
    LocalResourceId parentId;

    /** ID of next sibling in the resource tree */
    LocalResourceId nextSiblingId;

    /** ID of the mount point */
    MountPointId mountPointId;
};

struct ConstSymbolicLink
{
    /** Name of the resource */
    StringId nameId;

    /** A value indicating whether this is some other type than path (0 = path, 1 = other type) */
    uint8 isOtherType : 1;

    /** A value indicating the other type, see enum OtherType (0 = mount point, 1 = symlink) */
    uint8 otherType : 1;

    /** Reserved for future use */
    uint8 reserved : 6;

    /** Reserved for alignment */
    uint8 reserved2;

    /** ID of the parent resource */
    LocalResourceId parentId;

    /** ID of next sibling in the resource tree */
    LocalResourceId nextSiblingId;

    /** ID of the linked resource */
    LocalResourceId linkedResourceId;
};

/** Helper structure for calculating required resource tree node data size */
struct ResourceTreeNodeContainer
{
    /** Union of type data */
    union
    {
        /** Path information */
        Path path;

        /** Mount point information */
        MountPoint mountPoint;

        /** Const symbolic link information */
        ConstSymbolicLink constSymLink;
    };
};

// Check alignments
WB_STATIC_VERIFY(WB_TYPE_ALIGNMENT(Path) <= sizeof(uint16), AlignmentOfPathIsNotWhatExpected);
WB_STATIC_VERIFY(WB_TYPE_ALIGNMENT(MountPoint) <= sizeof(uint16), AlignmentOfMountPointIsNotWhatExpected);
WB_STATIC_VERIFY(WB_TYPE_ALIGNMENT(ConstSymbolicLink) <= sizeof(uint16), AlignmentOfConstSymbolicLinkIsNotWhatExpected);

/** Structure that stores resource tree node  data */
struct ResourceTreeNode
{
    /** Data storage for different tree node types. uint16 ensures correct alignment.
    */
    uint16 data[(sizeof(ResourceTreeNodeContainer) + sizeof(uint16) - 1) / sizeof(uint16)];

    /** Checks whether this node describes a standard path node
    *
    * @return true if standard path, false if one of the other node types
    */
    inline bool isStandardPath() const
    {
        // the node is either a standard path or some other type
        return reinterpret_cast<const Path*>(data)->isOtherType == 0;
    }

    /** Return the type of the node
    * @return ResourceTreeNodeType value of the node
    */
    inline ResourceTreeNodeType getNodeType() const
    {
        if (!reinterpret_cast<const Path*>(data)->isOtherType)
        {
            return NODE_TYPE_PATH;
        }
        const MountPoint* pMountPoint = reinterpret_cast<const MountPoint*>(data);
        return static_cast<ResourceTreeNodeType>(NODE_TYPE_MOUNTPOINT + pMountPoint->otherType);
    }

    /** Sets type of this node. Type must be set before type specific getters can be accessed
    *
    * @param nodeType The enumarated node type.
    */
    inline void setType(ResourceTreeNodeType nodeType)
    {
        if (NODE_TYPE_PATH == nodeType)
        {
            reinterpret_cast<Path*>(data)->isOtherType = 0;
        }
        else
        {
            MountPoint* pMountPoint = reinterpret_cast<MountPoint*>(data);
            pMountPoint->isOtherType = 1;
            pMountPoint->otherType = nodeType - 2;
        }
    }

    /** Checks whether this node describes a mount point
    *
    * @return true if the node is mount point.
    */
    inline bool isMountPoint() const
    {
        return NODE_TYPE_MOUNTPOINT == getNodeType();
    }

    /** Checks whether this node describes a constant symbolic link
    *
    * @return true if the node is a constant symbolic link.
    */
    inline bool isConstSymLink() const
    {
        return NODE_TYPE_CONSTSYMLINK == getNodeType();
    }

    /** Gets path node type
    *
    * @return Reference to path node
    */
    inline Path& getPath()
    {
        WB_DEBUG_ASSERT(!isMountPoint());
        return *reinterpret_cast<Path*>(data);
    }

    /** Gets path node type
    *
    * @return Reference to path node
    */
    inline const Path& getPath() const
    {
        WB_DEBUG_ASSERT(!isMountPoint());
        return *reinterpret_cast<const Path*>(data);
    }

    /** Gets mount point node type
    *
    * @return Reference to mount point node
    */
    inline MountPoint& getMountPoint()
    {
        WB_DEBUG_ASSERT(isMountPoint());
        return *reinterpret_cast<MountPoint*>(data);
    }

    /** Gets mount point node type
    *
    * @return Reference to mount point node
    */
    inline const MountPoint& getMountPoint() const
    {
        WB_DEBUG_ASSERT(isMountPoint());
        return *reinterpret_cast<const MountPoint*>(data);
    }

    /** Gets const symbolic link node type
    *
    * @return Reference to a const symbolic link node
    */
    inline const ConstSymbolicLink& getConstSymLink() const
    {
        WB_DEBUG_ASSERT(isConstSymLink());
        return *reinterpret_cast<const ConstSymbolicLink*>(data);
    }
};

/** Structure that stores resource tree related data */
struct ResourceTree
{ 
    const MetadataMap* pMetadataMap;
    LocalResourceId numberOfResources;
    const metadata::ResourceTreeNode* pTreeNodes;
    size_t numberOfSparseMapEntries;
    const LocalResourceId* pSparseMap;
    size_t numberOfMountPoints;
    const MountPoint* pMountPoints;
};

} // namespace metadata
} // namespace whiteboard
